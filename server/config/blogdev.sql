/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 80012
 Source Host           : localhost:3306
 Source Schema         : blogdev

 Target Server Type    : MySQL
 Target Server Version : 80012
 File Encoding         : 65001

 Date: 25/02/2019 13:49:17
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `content` text,
  `createdAt` datetime DEFAULT NULL,
  `updatedAt` datetime DEFAULT NULL,
  `userId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=71 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of article
-- ----------------------------
BEGIN;
INSERT INTO `article` VALUES (-1, '测试留言的文章！！！！', '不能删！！！数据库上有留言字段引用此ID', '2019-02-23 05:34:03', '2019-02-23 05:34:03', 0);
INSERT INTO `article` VALUES (1, 'mysql - 数据库操作和数据属性', '## 数据库操作\n\n启动 `mysql`, `mac` 可通过 `brew` 安装 `mysql` 后启动。 `window` 需要手动配置\n\n```js\n// mac\nmysql.server start\n\n// window\nnet start mysql\n\n// 登录 -u 用户名 root 超级用户 -p 密码\nmysql -uroot -p\n\n// 退出\nmysql > \\q\n\n// 切换到 learn 数据库\nmysql > use learn\n```\n<!--more-->\n\nMySQL 语句规范\n\n- 关键字与函数名称全部大写\n- 数据库名称，表名称，字段名称全部小写\n- SQL 语句必须以分号结尾\n\n```js\n// 创建数据库 默认编码 utf-8\nCREATE DATABASE IF NOT EXISTS t1;\n\n// 创建 gbk 编码的数据库\nCREATE DATABASE IF NOT EXISTS t2 CHARACTER SET gbk;\n\n//显示创建数据库 t1 的指令\nSHOW CREATE DATABASE t1;\n\n// 查看数据库\nSHOW DATABASES;\n\n// 删除数据库\nDROP DATABASE IF EXISTS t1;\n```\n\n## 数据类型\n\n### 整型\n\n| MySQL 数据类型 | 含义     | （有符号）                   |\n| -------------- | -------- | ---------------------------- |\n| tinyint(m)     | 1 个字节 | 范围(-128~127)               |\n| smallint(m)    | 2 个字节 | 范围(-32768~32767)           |\n| mediumint(m)   | 3 个字节 | 范围(-8388608~8388607)       |\n| int(m)         | 4 个字节 | 范围(-2147483648~2147483647) |\n| bigint(m)      | 8 个字节 | 范围(+-9.22\\*10 的 18 次方)  |\n\n比如我们存储年龄，范围为 0-100 ，此时我们可以使用 `TINYINT` 存储\n\n\n### 浮点型(float和double)\n\n| MySQL数据类型 | 含义                                           |\n| ------------- | ---------------------------------------------- |\n| float(m,d)    | 单精度浮点型 8位精度(4字节)  m总个数，d小数位  |\n| double(m,d)   | 双精度浮点型 16位精度(8字节)  m总个数，d小数位 |\n\n设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200.\n\n\n### 字符串(char,varchar,_text)\n\n| MySQL数据类型 | 含义                            |\n| ------------- | ------------------------------- |\n| char(n)       | 固定长度，最多255个字符         |\n| varchar(n)    | 固定长度，最多65535个字符       |\n| tinytext      | 可变长度，最多255个字符         |\n| text          | 可变长度，最多65535个字符       |\n| mediumtext    | 可变长度，最多2的24次方-1个字符 |\n| longtext      | 可变长度，最多2的32次方-1个字符 |\n\n\n`char`和`varchar`：\n\n1.`char(n)` 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，`varchar`不限于此。 \n\n2.`char(n)` 固定长度，char(4)不管是存入几个字符，都将占用4个字节，`varchar`是存入的实际字符数+1个字节（n<=255）或2个字节(n>255)，\n\n所以`varchar`(4),存入3个字符将占用4个字节。 \n\n\n3.char类型的字符串检索速度要比`varchar`类型的快。\n`varchar`和`text`： \n\n1.`varchar`可指定n，`text`不能指定，内部存储`varchar`是存入的实际字符数+1个字节（n<=255）或2个字节(n>255)，`text`是实际字符数+2个字\n\n节。 \n\n2.`text`类型不能有默认值。 \n\n3.`varchar`可直接创建索引，`text`创建索引要指定前多少个字符。`varchar`查询速度快于`text`,在都创建索引的情况下，`text`的索引似乎不起作用。\n\n \n\n5.二进制数据(_Blob)\n\n1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。\n\n2._BLOB存储的数据只能整体读出。 \n\n3._TEXT可以指定字符集，_BLO不用指定字符集。\n\n### 日期时间类型\n\n| MySQL数据类型 | 含义                          |\n| ------------- | ----------------------------- |\n| date          | 日期 \'2008-12-2\'              |\n| time          | 时间 \'12:25:36\'               |\n| datetime      | 日期时间 \'2008-12-2 22:06:44\' |\n| timestamp     | 自动存储记录修改时间          |\n\n## 数据类型的属性\n\n| MySQL关键字        | 含义                     |\n| ------------------ | ------------------------ |\n| NULL               | 数据列可包含NULL值       |\n| NOT NULL           | 数据列不允许包含NULL值   |\n| DEFAULT            | 默认值                   |\n| PRIMARY KEY        | 主键                     |\n| AUTO_INCREMENT     | 自动递增，适用于整数类型 |\n| UNSIGNED           | 无符号                   |\n| CHARACTER SET name | 指定一个字符集           |', '2019-02-11 12:19:35', '2019-02-11 12:19:35', 1);
INSERT INTO `article` VALUES (2, 'mysql - 对 table 的操作', '## 创建表\n\n```sql\nmysql.server start // net start mysql\n\nmysql -uroot -p // login\n\nuse test // 进入数据库\n\nCREATE TABLE [IF NOT EXISTS] table_name (\n  column_name data_type,\n  // ...\n)\n```\n<!--more-->\n\n### demo1 \n\n创建 `tb1` 表\n\n```sql\nCREATE TABLE IF NOT EXISTS tb1 (\n  username VARCHAR(20) NOT NULL,\n  age TINYINT UNSIGNED,\n  salary FLOAT(8, 2) UNSIGNED\n);\n\nSHOIW TABLES; --查看数据库中的表\n\nSHOW COLUMNS FROM tb1; --查看数据表中的结构\n```\n\n| Field | Type  | Null | Key | Default | Extra |\n| :---: | :---: |:--: | :-: | :-----: | :---: |\n| username |     varchar(20)     | YES  |     |  null   |       |\n|   age    | tinyint(3) unsigned | YES  |     |  null   |       |\n|  salary  | float(8,2) unsigned | YES  |     |  null   |       |\n\n- username: 用户的名字往往是字符型，字符数据量小，所以数据类型定为 `VARCHAR(20)`, `NOT NULL` 不能为空\n- age: 年龄不能为负值且为整型，数据类型定为 `TINYINT`\n- salary: `FLOAT(8, 2)` 整数八位 - 小数有两位，非负值\n\n### demo2\n\n```sql\nCREATE TABLE IF NOT EXISTS tb3(\n  id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(20) NOT NULL UNIQUE KEY,\n  sex ENUM (\'1\',\'2\',\'3\') DEFAULT \'3\'\n);\n\n-- AUTO_INCREMENT: 自增字段，必须为主键 `PRIMARY KEY`，保证记录的唯一性.\n-- UNIQUE KEY: 唯一\n-- DEFAULT: 默认\n```\n\n\n| Field | Type  | Null | Key | Default | Extra |\n| :---: | :---: |:--: | :-: | :-----: | :------------: |\n|    id    |    smallint(5)    |  NO  | PRI |  null   | auto_increment |\n| username |    varchar(20)    |  NO  |     |  null   |                |\n|   sex    | enum(\'1\',\'2\',\'3\') | YES  |     |    3    |                |\n\n\n## 约束\n\n- 约束保证数据的完整性和一致性。\n- 约束表现为表级约束和列级约束。\n- 约束类型包括\n  - `NOT NULL` 非空\n  - `PRIMARY KEY` 主键\n  - `UNIQUE` 唯一\n  - `DEFAULT` 默认\n  - `FOREIGN KEY` 外键 (foreign key)\n\n> 外键约束：保持数据一致性，完整性，实现一对多或者多对一的关系\n\n> 表级约束：针对两个或者两个以上的字段来使用\n\n> 列级约束：只针对某一个字段来使用\n\n### 外键约束\n\n1.  父表和子表必须使用相同的存储引擎，而且禁止使用临时表\n2.  数据表的存储引擎只能为 InnoDB\n3.  外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。\n4.  外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL 将自动创建索引。\n\n```sql\n-- 身份表\nCREATE TABLE IF NOT EXISTS provinces (\n  id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,\n  pname VARCHAR(20) NOT NULL\n);\n\n-- 用户表\nCREATE TABLE IF NOT EXISTS users (\n   id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,\n   username VARCHAR(10) NOT NULL,\n   pid SMALLINT UNSIGNED,\n   FOREIGN KEY(pid) REFERENCES provinces(id) -- 设置 pid 外键 references provinces 表的 id\n);\n\n-- 外键列和参照列必须具有相似的数据类型: pid BIGINT， 是创建不成功的。保证数据类型相同是第一步\n-- 数字的长度或是否有符号位必须相同：pid SMALLINT, 同样创建不成功。有符号位位必须相同。pid SMALLINT UNSIGNED 就满足条件了\n-- 外键列和参照列必须创建索引:, 我们没有创建，MySQL 自动创建了索引。\n\n-- 主键在创建的同时，会自动创建索引。\nSHOW INDEXES FROM provinces\\G; -- Seq_in_index: 1\n```\n\n1. 我们创建了父表 `provinces`, 子表 `users`\n2. 外键列：pid , 参照列 id\n\n\n## 对 table column 的操作\n\n列的增加、删除，约束的添加、约束的删除。\n\n```sql\n-- 添加单列\nalter table tbl_name add [column] col_name col_difinition[first|after col_name]\n\n-- 解释：first 插入第一列，after col_name 插入某一列后面。省略不写，加在最后列\n\n-- 添加多列\nalter table tbl_name add [column] (col_name col_difinition,...)\n\n-- 删除列\nalter table tbl_name drop[column] col_name1,col_name2;\n\n\n-- demo\nALTER TABLE users ADD age TINYINT NOT NULL DEFAULT 10;\nALTER TABLE users ADD password VARCHAR(32) NOT NULL AFTER username;\nALTER TABLE users DROP password, DROP username;\n```\n\n```sql\n-- 修改数据表【添加或删除约束】：\n\nALTER TABLE table_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type](index_col_name,...) -- 这是添加主键约束(只能有一个)\n\nALTER TABLE table_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX/KEY] [index_name] [index_type] (index_col_name,...); --这是添加唯一约束(可以有多个)\n\nALTER TABLE table_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name,...) reference_definition; --这是添加外键约束(可以有多个)\n\nALTER TABLE table_name ALTER [COLUMN] col_name {SET DEFAULT literal(这个literal的意思是加上的default)/DROP DEFAULT} --添加或删除默认约束\n\nALTER TABLE table_name DROP PRIMARY KEY; -- 删除主键约束\n\nALTER TABLE table_name DROP {INDEX/KEY} index_name; --删除唯一约束\n\nALTER TABLE table_name DROP FOREIGN KEY fk_symbol; --删除外键约束\n\n\n-- demo\nCREATE TABLE IF NOT EXISTS users2 (\n  username VARCHAR(10) NOT NULL,\n  pid SMALLINT UNSIGNED\n);\n\nALTER TABLE users2 ADD id SMALLINT UNSIGNED;\n\n-- 添加主键约束\nALTER TABLE users2 ADD CONSTRAINT PRIMARY KEY(id);\n\n-- 添加唯一约束\nALTER TABLE users2 ADD UNIQUE (username);\n\n-- 添加外键\nALTER TABLE users2 ADD FOREIGN KEY (pid) REFERENCES provinces (id);\n\n-- 添加默认约束\nALTER TABLE users2 ADD age TINYINT UNSIGNED NOT NULL;\n\nALTER TABLE users2 ALTER age SET DEFAULT 22;\n\n-- 删除默认约束\nALTER TABLE users2 ALTER age DROP DEFAULT;\n\n-- 删除主键约束\nALTER TABLE users2 DROP PRIMARY KEY;\n\n-- 删除唯一约束\nALTER TABLE users2 DROP INDEX username;\n\n-- 删除外键约束\nSHOW CREATE TABLE users2 --  CONSTRAINT `users2_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `provinces` (`id`)\n\nALTER TABLE users2 DROP FOREIGN key users2_ibfk_1;\n```', '2019-02-11 12:21:15', '2019-02-11 12:21:15',2);
INSERT INTO `article` VALUES (3, 'mysql - column 的增删改查', '创建数据\n\n```sql\n-- DROP TABLE users; 创建过 users 表可以使用这个语句删除\n\n-- 创建表\nCREATE TABLE IF NOT EXISTS users(\n  id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,\n  username VARCHAR(20) NOT NULL,\n  password VARCHAR(32) NOT NULL,\n  age TINYINT UNSIGNED NOT NULL DEFAULT 10,\n  sex TINYINT\n);\n```\n\n<!--more-->\n\n## 插入数据\n\n- INSERT INTO 表名 VALUE\n- INSERT INTO 表名 set 列名 = xxx (可以进行子查询)\n- INSERT INTO 表名 SELECT ,,,,,,, (将查询结果插入指定的表中)\n\n```sql\n-- 插入数据\nINSERT users VALUES (NULL, \'TOM\', \'1234\', 22, 1); -- 一个列都不能漏\n\n-- 插入多条数据\nINSERT users VALUES (NULL, \'TOM\', \'1234\', 22, 1), (DEFAULT, \'Jhon\', \'4321\', DEFAULT, 1);\n\n-- set方法 与第一种方式的区别是，此方法可以使用子查询，但是一次性只能插入一条记录。\nINSERT users SET username=\'BEN\',password=\'569\'; --其余字段有默认值或者允许为空\n```\n\n## 更新数据\n\nUPDATA 表名 SET 字段名=值|表达式 WHERE 判断条件 (如省略 where 筛选,则更新所有记录)\n\n```sql\nUPDATE users SET age = age + 5;\n\nUPDATE users SET age=age-id,sex=0;\n\nUPDATE users SET age=age+10 where id % 2 =0;\n```\n\n## 删除数据\n\n```sql\nDELETE FROM tbl_name [WHERE where_condition]\n```\n\n## 查找记录\n\n```sql\n查找记录：SELECT select_expr [,select_expr ……]\n[FROM table_referrnces [WHERE where_condition]\n[GROUP BY{col_name | position} [ASC | DESCI],……]\n[HAVING where_condition]\n[ORDER BY {col_name |expr |position} [ASC | DESCI],……]\n\n-- demo\nSELECT id, username FROM users;\n\n-- 别名\nSELECT id AS userId, username AS name FROM users;\n```\n\n### 查询分组\n\n```sql\nSELECT sex FROM users GROUP BY sex  -- 数据库多条记录会被合并，譬如这里只有 1, null\n```\n\n- 分组条件 [HAVING where_condotion]\n\n`having` 后的条件必须为聚合函数或者出现在 `select` 所选择的字段中。\n\n```sql\nSELECT sex FROM users GROUP BY sex -- 对所有记录分组\n\n-- 报错 having 后的条件必须为聚合函数或者出现在 select 所选择的字段中。\nSELECT sex FROM users GROUP by sex  having age>35;\n\nSELECT sex FROM users GROUP BY sex HAVING count(id) > 2;\n```\n\n- 排序\n\n```sql\n-- 首先按照age升序排列（asc），其次按照id降序排列（desc）\nSELECT * FROM users ORDER BY age,id DESC;\n```\n\n- 限制返回的数据的数量\n\n1. select \\_ from users limit 2 意思为从取前两条记录。\n2. select \\_ from users limit 3,2 意思为从第 4 条记录开始取两条，而不是从第三条记录开始。\n3. ...\n\n### 子查询与链接\n\n```SQL\nuse test;\n\nCREATE TABLE IF NOT EXISTS tb4(\n  goodsId SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,\n  goodsName VARCHAR(20) NOT NULL,\n  price FLOAT UNSIGNED\n);\n\nINSERT tb4 VALUES (NULL, \'goods1\', 12.8), (NULL, \'goods2\', 95.8), (NULL, \'goods3\', 15.8), (NULL, \'goods2\', 50.5);\n\n-- 查找平均值\nselect avg(price) from tb4;\n\n-- 对平均值四舍五入\nselect round(avg(price), 2) from tb4; -- 保留两位小数\n\n-- 使用比较\nselect goodsId, goodsName, price from tb4 where price >= 20;\n\n-- 查找大于平均价格的\nselect goodsId, goodsName, price from tb4 where price >= (select round(avg(price), 2) from tb4);\n```\n| 运算符/关键字 |  ANY   |  SOME  |  ALL   |\n| :-----------: | :----: | :----: | :----: |\n|     >、>=     | 最小值 | 最小值 | 最大值 |\n|     <、<=     | 最大值 | 最大值 | 最小值 |\n|       =       | 任意值 | 任意值 |        |\n|    <>、!=     |        |        | 任意值 |\n\n使用[NOT]EXISTS 的子查询：如果子查询返回任何行，EXISTS 将返回 TURE；否则返回 FALSE.\n\n```sql\nselect * from tb4 where price >= all (select round(avg(price), 2) from tb4); -- 任意大于平均价格的记录\n```\n\n\n## 数据增删改查-demo（单表）\n\n### INSERT\n\n```sql\nCREATE TABLE IF NOT EXISTS goods (\n  id SMALLINT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(20) NOT NULL,\n  price FLOAT UNSIGNED,\n  origin VARCHAR(20) DEFAULT \'CHINA\'\n);\n\n\n-- 插入单条记录\nINSERT goods VALUES(NULL, \'oppo\', 5399, DEFAULT);\n\n-- 插入多条记录\nINSERT goods VALUES(NULL, \'iphone\', 8999, \'US\'), (NULL, \'meizu\', 6999, DEFAULT);\n\n-- SET 插入\nINSERT goods SET name=\'xiaomi\', price=999;\n\n-- SET 插入多条\nINSERT INTO goods (goodsName, price) VALUES(\'ss\',25),(\'bb\',125);\n```\n\n### SELECT\n\n```sql\nSELECT * FROM goods;\n\nSELECT goodsName, price FROM goods;\n\nSELECT goodsName, price FROM goods WHERE price > 1000; -- 加条件筛选\n```\n\n### UPDATE\n\n```sql\n-- 找到 iphone , 修改名字为 iphonX, 价格 9999\nUPDATE goods SET goodsName=\'iphonX\', price=9999 WHERE goodsName=\'iphone\';\n```\n\n### DELETE\n\n```SQL\nDELETE FROM goods WHERE goodsName=\'ss\'; -- DELETE FROM goods 删除所有\n```\n\n多表有 `left join` 、 `inner` 等等，这里不再讲述。', '2019-02-11 12:22:15', '2019-02-11 12:22:15', 3);
INSERT INTO `article` VALUES (4, ' mysql - 聚合函数', '## 聚合函数（aggregation function）\n\n> 聚合函数（`aggregation function`）---也就是组函数，在一个行的集合（一组行）上进行操作，对每个组给一个结果。\n\n常用的组函数：\n\n| function                     | return       |\n| ---------------------------- | ------------ |\n| AVG([distinct] expr)         | 求平均值     |\n| COUNT({*  [distinct] } expr) | 统计行的数量 |\n| MAX([distinct] expr)         | 求最大值     |\n| MIN([distinct] expr)         | 求最小值     |\n| SUM([distinct] expr)         | 求累加和     |\n\n<!-- more -->\n\n1. 每个组函数接收一个参数\n2. 默认情况下，组函数忽略列值为null的行，不参与计算\n3. 有时，会使用关键字distinct剔除字段值重复的条数\n\n注意：\n\n- 当使用组函数的 `select` 语句中没有 `group by` 子句时，中间结果集中的所有行自动形成一组，然后计算组函数；\n- 组函数不允许嵌套，例如：`count(max(…))`；\n- 组函数的参数可以是列或是函数表达式；\n- 一个 `SELECT` 子句中可出现多个聚集函数。\n\n\n```bash\nmysql> select * from users;\n+----+----------+------+---------------------+---------------------+\n| id | name     | age  | createdAt           | updatedAt           |\n+----+----------+------+---------------------+---------------------+\n|  1 | guodada  |   18 | 2019-10-04 05:56:52 | 2019-10-04 05:56:52 |\n|  2 | guodada2 |   18 | 2019-10-04 05:57:01 | 2019-10-04 05:57:01 |\n|  3 | guodada3 | NULL | 2019-10-04 05:58:00 | 2019-10-04 05:58:00 |\n+----+----------+------+---------------------+---------------------+\n3 rows in set (0.00 sec)\n```\n\n## count 函数\n\n① `count(*)`：返回表中满足 `where` 条件的行的数量\n\n```sql\nSELECT COUNT(*) AS count FROM users WHERE age > 10 -- count 3\n```\n\n② `count(列)`：返回列值非空的行的数量\n\n```sql\nSELECT COUNT(age) AS count FROM users -- count 2\n```\n\n③ `count(distinct 列)`：返回列值非空的、并且列值不重复的行的数量\n\n```sql\nSELECT COUNT(distinct age) AS count FROM users -- count 1\n```\n\n④ `count(expr)`：根据表达式统计数据\n\n```sql\nSELECT COUNT(age=18) AS count FROM users; -- count 2\n```\n\n## max 和 min 函数---统计列中的最大最小值\n\n```sql\nSELECT MAX(age) as maxAge FROM users -- maxAge 18\nSELECT MIN(age) as minAge FROM users -- minAge 18\n```\n\n> 注意：如果统计的列中只有 `NULL` 值，那么 `MAX` 和 `MIN` 就返回 `NULL`\n\n## sum 和 avg 函数---求和与求平均\n\n！！表中列值为 `null` 的行不参与计算\n\n```sql\nSELECT AVG(age) as avgAge FROM users -- avgAge 18\nSELECT SUM(age) as snmAge FROM users -- sumAge 36\n```\n\n注意：要想列值为 `NULL` 的行也参与组函数的计算，必须使用 `IFNULL` 函数对 `NULL` 值做转换。\n\n## 分组聚合查询\n\n分组 SELECT 的基本格式：\n\n`select [聚合函数] 字段名 from 表名 [where 查询条件] [group by 字段名] [having 过滤条件]`\n\n```bash\nmysql> select name, count(*) as count from users where age > 10 group by name;\n+----------+-------+\n| name     | count |\n+----------+-------+\n| guodada  |     1 |\n| guodada2 |     1 |\n+----------+-------+\n2 rows in set (0.00 sec)\n```\n\n通过 `select` 在返回集字段中，这些字段要么就要包含在 `group by` 语句后面，作为分组的依据，要么就要被包含在聚合函数中。我们可以将 `group by` 操作想象成如下的一个过程：首先系统根据 `select` 语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成了一条记录。这个时候剩下的那些不存在与 `group by` 语句后面作为分组依据的字段就很有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这个时候就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是前面讲到的聚合函数，这也就是为什么这些函数叫聚合函数了。\n\n- [MySQL最常用分组聚合函数](https://www.cnblogs.com/geaozhang/p/6745147.html#sum-avg)', '2019-02-11 12:24:26', '2019-02-11 12:24:26',4);
INSERT INTO `article` VALUES (5, 'react 入门', '```html\n<script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n<script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n<!-- 生产环境中不建议使用 -->\n<script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n\n<div id=\"example\"></div>\n<script type=\"text/babel\">\nReactDOM.render(\n    <h1>Hello, world!</h1>,\n    document.getElementById(\'example\')\n);\n</script>\n```\n\n- react.min.js - React 的核心库\n- react-dom.min.js - 提供与 DOM 相关的功能\n- babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码\n\n<!--more-->\n\n## 使用 create-react-app 快速构建 React 开发环境\n\n```\ncnpm install -g create-react-app\ncreate-react-app my-app\nnpm run eject\n```\n\n`TodoList`\n```jsx\nimport React, {Component} from \'react\';\n\nclass TodoList extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n            list: [],\n            inputValue: \'\'\n        }\n\n        this.handleChange = this.handleChange.bind(this)\n        this.handleBtnClick = this.handleBtnClick.bind(this)\n    }\n\n    handleChange(e) {\n        this.setState({\n            inputValue: e.target.value\n        })\n    }\n\n    handleBtnClick() {\n        this.setState(\n            {\n                list: [...this.state.list, this.state.inputValue],\n                inputValue: \'\'\n            }\n        )\n    }\n\n    handleItemClick(index) {\n        let list = [...this.state.list]\n        list.splice(index, 1)\n        this.setState({\n            list\n        })\n    }\n\n    render() {\n        return (\n            <div>\n                <div>\n                    <input value={this.state.inputValue} onChange={this.handleChange}/>\n                    <button onClick={this.handleBtnClick} className=\'btn\'>add</button>\n                </div>\n                <ul>\n                    {\n                        this.state.list.map((item, index) => {\n                            return (\n                                <li key={index} onClick={this.handleItemClick.bind(this, index)}>{item}</li>\n                            )\n                        })\n                    }\n                </ul>\n            </div>\n        )\n    }\n}\n\nexport default TodoList\n```\n\n组件化 \n`todoList`\n\n```js\nimport React, {Component} from \'react\';\nimport TodoItem from \'./TodoItem\'\n\nclass TodoList extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n            list: [],\n            inputValue: \'\'\n        }\n\n        this.handleChange = this.handleChange.bind(this)\n        this.handleBtnClick = this.handleBtnClick.bind(this)\n    }\n\n    handleChange(e) {\n        this.setState({\n            inputValue: e.target.value\n        })\n    }\n\n    handleBtnClick() {\n        this.setState(\n            {\n                list: [...this.state.list, this.state.inputValue],\n                inputValue: \'\'\n            }\n        )\n    }\n\n    handleItemClick(index) {\n        let list = [...this.state.list]\n        list.splice(index, 1)\n        this.setState({list})\n    }\n\n    render() {\n        return (\n            <div>\n                <div>\n                    <input value={this.state.inputValue} onChange={this.handleChange}/>\n                    <button onClick={this.handleBtnClick} className=\'btn\'>add</button>\n                </div>\n                <ul>\n                    {\n                        this.state.list.map((item, index) => {\n                            // return (\n                            //     <li key={index} onClick={this.handleItemClick.bind(this, index)}>{item}</li>\n                            // )\n                            return (\n                                <TodoItem\n                                    key={index}\n                                    content={item}\n                                    index={index}\n                                    delete={this.handleItemClick.bind(this, index)}\n                                />\n                            )\n                        })\n                    }\n                </ul>\n            </div>\n        )\n    }\n}\n\nexport default TodoList\n```\n`todoItem`\n``` jsx\nimport React, {Component} from \'react\';\n class TodoItem extends Component {\n     constructor(props) {\n        super(props)\n        this.handleDelete = this.handleDelete.bind(this)\n    }\n     // 子组件想要和父组件通信，要调用父组件传递过来的方法\n     handleDelete(index) {\n        this.props.delete(index)\n    }\n     // 父组件通过属性的形式向子组件传递参数\n    // 子组件通过props接受父组件传递过来的参数\n     render() {\n        return (\n            <li onClick={this.handleDelete}>{this.props.content}</li>\n        )\n    }\n}\n export default TodoItem\n```', '2019-02-11 12:25:21', '2019-02-23 04:27:26',5);
INSERT INTO `article` VALUES (6, 'react-context 实现 todoList', '`src/context/TodoContext.js`\n\n```jsx\nimport React, { Component } from \'react\'\n\nexport const TodoContext = React.createContext()\n\nexport class TodoProvider extends Component {\n  state = {\n    todoList: []\n  }\n\n  addTodo = text => {\n    const todoList = [...this.state.todoList, { id: Math.random(), text }]\n    this.setState({ todoList })\n  }\n\n  deleteTodo = id => {\n    const todoList = this.state.todoList.filter(todo => todo.id !== id)\n    this.setState({ todoList })\n  }\n\n  clearTodos = () => {\n    this.setState({ todoList: [] })\n  }\n\n  render() {\n    return (\n      <TodoContext.Provider\n        value={{\n          todoList: this.state.todoList,\n          addTodo: this.addTodo,\n          deleteTodo: this.deleteTodo,\n          clearTodos: this.clearTodos\n        }}>\n        {this.props.children}\n      </TodoContext.Provider>\n    )\n  }\n}\n```\n<!--more-->\n\n`App.jsx`\n\n```jsx\nimport React, { Component } from \'react\'\n\nimport { TodoContext, TodoProvider } from \'./context/TodoContext\'\n\nclass App extends Component {\n  state = {\n    text: \'\'\n  }\n\n  render() {\n    const { todoList, addTodo, deleteTodo, clearTodos } = this.props\n    const { text } = this.state\n    return (\n      <div>\n        <h2>TodoList</h2>\n        <div>\n          <input\n            type=\"text\"\n            placeholder=\"请输入内容\"\n            onChange={e => this.setState({ text: e.target.value })}\n          />\n          <button onClick={e => addTodo(text)}>AddTodo</button>\n          <button onClick={clearTodos}>clearTodos</button>\n        </div>\n        <ul>\n          {todoList.map(todo => (\n            <li key={todo.id}>\n              {todo.text}\n              <button onClick={e => deleteTodo(todo.id)}>delete</button>\n            </li>\n          ))}\n        </ul>\n      </div>\n    )\n  }\n}\n\nconst Hoc = WrappedComponent =>\n  class extends Component {\n    render() {\n      return (\n        <TodoProvider>\n          <TodoContext.Consumer>\n            {ctx => <WrappedComponent {...ctx} />}\n          </TodoContext.Consumer>\n        </TodoProvider>\n      )\n    }\n  }\n\nexport default Hoc(App)\n```', '2019-02-11 12:26:32', '2019-02-23 04:27:13',6);
INSERT INTO `article` VALUES (7, 'react-context', '## 简单使用\n\n`Context` 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 `redux`，因为 `redux` 也是通过这个东东实现的。\n\n```jsx\nimport React, { Component } from \'react\'\n\n/**\n * 1. 创建 context\n * 2. 根组件 App 包裹 MyContext.Provider\n * 3. App => Father => Child => MyContext.Consumer => context.age 取出结果\n */\nconst MyContext = React.createContext()\n\nconst Child = () => (\n  <MyContext.Consumer>{({ age }) => <p>My age is {age}</p>}</MyContext.Consumer>\n)\n\nconst Father = () => <Child />\n\nclass App extends Component {\n  render() {\n    return (\n      <MyContext.Provider value={{ age: 22 }}>\n        <Father />\n      </MyContext.Provider>\n    )\n  }\n}\n\nexport default App\n```\n<!--more-->\n\n## 理论知识\n\n### React.createContext\n\n```jsx\nconst { Provider, Consumer } = React.createContext(defaultValue)\n```\n\n创建一对 { `Provider`, `Consumer` }。当 React 渲染 `context` 组件 `Consumer` 时，它将从组件树的上层中最接近的匹配的 `Provider` 读取当前的 `context` 值。\n\n### Provider\n\n```jsx\n<Provider value={/* some value */}>\n\n```\n\nReact 组件允许 `Consumers` 订阅 `context` 的改变。\n接收一个 `value` 属性传递给 `Provider` 的后代 `Consumers`。一个 `Provider` 可以联系到多个 `Consumers`。Providers 可以被嵌套以覆盖组件树内更深层次的值。\n\n### Consumer\n\n```jsx\n<Consumer>\n  {value => /* render something based on the context value */}\n</Consumer>\n```\n\n一个可以订阅 `context` 变化的 React 组件。\n\n注意，`MyContext.Consumer` 使用的是 `render props` 这种模式，`render props` 模式指的是让 `prop` 可以是一个 `render` 函数\n\n## 父子耦合\n\n经常需要从组件树中某个深度嵌套的组件中更新 `context`。在这种情况下，可以通过 `context` 向下传递一个函数，以允许 `Consumer` 更新 `context` ：\n\n```jsx\nimport React, { Component } from \'react\'\n\nconst MyContext = React.createContext()\n\nconst Child = () => (\n  <MyContext.Consumer>\n     {ctx => (\n      <div>\n        <p>My age is {ctx.age}</p>\n        <button onClick={ctx.changeAge}>changeAge</button>\n      </div>\n    )}\n  </MyContext.Consumer>\n)\n\nconst Father = () => <Child />\n\nclass App extends Component {\n  state = {\n    age: 22\n  }\n  \n  changeAge = () => {\n    this.setState(prevState => ({\n      age: ++prevState.age\n    }))\n  }\n\n  render() {\n    return (\n      <MyContext.Provider value={{\n        age: this.state.age,\n        changeAge: this.changeAge\n      }}>\n        <Father />\n      </MyContext.Provider>\n    )\n  }\n}\n\nexport default App\n```\n\n## 作用于多个上下文\n\n为了保持 `context` 快速进行二次渲染， `React` 需要使每一个 `Consumer` 在组件树中成为一个单独的节点。\n\n```jsx\nimport React, { Component } from \'react\'\n\nconst MyContext = React.createContext()\n\nconst UserContext = React.createContext()\n\nconst Child = () => (\n  <MyContext.Consumer>\n    {ctx => (\n      <UserContext.Consumer>\n        {user => (\n          <div>\n            <p>My name is {user.name}</p>\n            <p>My age is {ctx.age}</p>\n            <button onClick={ctx.changeAge}>changeAge</button>\n          </div>\n        )}\n      </UserContext.Consumer>\n    )}\n  </MyContext.Consumer>\n)\n\nconst Father = () => <Child />\n\nclass App extends Component {\n  state = {\n    age: 22,\n    name: \'郭大大\'\n  }\n\n  changeAge = () => {\n    this.setState(prevState => ({\n      age: ++prevState.age\n    }))\n  }\n\n  render() {\n    return (\n      <MyContext.Provider\n        value={{\n          age: this.state.age,\n          changeAge: this.changeAge\n        }}>\n        <UserContext.Provider value={{ name: this.state.name }}>\n          <Father />\n        </UserContext.Provider>\n      </MyContext.Provider>\n    )\n  }\n}\n\nexport default App\n```\n\n如果两个或者多个上下文的值经常被一起使用，也许你需要考虑你自己渲染属性的组件提供给它们。\n\n\n## 在生命周期方法中访问 Context\n\n在生命周期方法中从上下文访问值是一种相对常见的用例。而不是将上下文添加到每个生命周期方法中，只需要将它作为一个 `props` 传递，然后像通常使用 `props` 一样去使用它。\n\n```jsx\nimport React, { Component } from \'react\'\n\nconst MyContext = React.createContext()\n\nclass Child extends Component {\n  \n  componentDidMount() {\n   console.log(this.props.ctx) \n  }  \n\n  render() {\n    const { age, changeAge } = this.props.ctx\n    return (\n      <div>\n        <p>My age is {age}</p>\n        <button onClick={changeAge}>changeAge</button>\n      </div>\n    )\n  }\n}\n\n\nconst Father = props => (\n  <MyContext.Consumer>\n    {ctx => <Child {...props} ctx={ctx} />}\n  </MyContext.Consumer>\n)\n\nclass App extends Component {\n  state = {\n    age: 22\n  }\n\n  changeAge = () => {\n    this.setState(prevState => ({\n      age: ++prevState.age\n    }))\n  }\n\n  render() {\n    return (\n      <MyContext.Provider\n        value={{\n          age: this.state.age,\n          changeAge: this.changeAge\n        }}>\n        <Father />\n      </MyContext.Provider>\n    )\n  }\n}\n\nexport default App\n```\n\n## 转发 Refs\n\n一个关于渲染属性API的问题是 `refs` 不会自动的传递给被封装的元素。为了解决这个问题，使用 `React.forwardRef`：\n\n- fancy-button.js\n\n```jsx\nclass FancyButton extends React.Component {\n  focus() {\n    // ...\n  }\n\n  // ...\n}\n\n// 使用 context 传递当前的 \"theme\" 给 FancyButton.\n// 使用 forwardRef 传递 refs 给 FancyButton 也是可以的.\nexport default React.forwardRef((props, ref) => (\n  <ThemeContext.Consumer>\n    {theme => (\n      <FancyButton {...props} theme={theme} ref={ref} />\n    )}\n  </ThemeContext.Consumer>\n))\n```\n- app.js\n\n```jsx\nimport FancyButton from \'./fancy-button\'\n\nconst ref = React.createRef()\n\n// ref属性将指向 FancyButton 组件,\n// ThemeContext.Consumer 没有包裹它\n// 这意味着我们可以调用 FancyButton 的方法就像这样 ref.current.focus()\n<FancyButton ref={ref} onClick={handleClick}>\n  Click me!\n</FancyButton>\n```\n\n## 尽量减少使用 context\n\n因为 `context` 使用 `reference identity` 确定何时重新渲染，在 `Consumer` 中，当一个 `Provider` 的父节点重新渲染的时候，有一些问题可能触发意外的渲染。例如下面的代码，所有的 `Consumner` 在 `Provider` 重新渲染之时，每次都将重新渲染，因为一个新的对象总是被创建对应 `Provider` 里的 value\n\n```jsx\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={{something: \'something\'}}>\n        <Toolbar />\n      </Provider>\n    );\n  }\n}\n```\n\n为了防止这样, 提升 `value` 到父节点的 `state` 里:\n\n```jsx\nclass App extends React.Component {\n  constructor(props) {\n    this.state = {\n      value: {something: \'something\'},\n    };\n  }\n\n  render() {\n    return (\n      <Provider value={this.state.value}>\n        <Toolbar />\n      </Provider>\n    );\n  }\n}\n```\n\n## 注意点\n\nReact context的局限性：\n\n1. 在组件树中，如果中间某一个组件 ShouldComponentUpdate returning false 了，会阻碍 context 的正常传值，导致子组件无法获取更新。\n2. 组件本身 extends React.PureComponent 也会阻碍 context 的更新。\n3. Context 应该是唯一不可变的\n4. 组件只在初始化的时候去获取 Context\n', '2019-02-11 12:26:54', '2019-02-23 04:27:03',7);
INSERT INTO `article` VALUES (8, 'react - 高阶组件', '## 高阶函数 / 柯理化\n\n> 高阶函数（`Higher Order Function`）=> 参数或返回值为函数\n\n比较常见的有数组的遍历方式 Map、Reduce、Filter、Sort；常用的 redux 中的 `connect` 方法也是高阶函数。\n\n```js\n// 高阶函数 - 简单的例子\nfunction add(a, b, fn) {\n  return fn(a) + fn(b)\n}\nvar fn = function(a) {\n  return a * a\n}\nadd(2, 3, fn) // 13\n```\n\n> 函数柯里化 接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术\n\n```js\nconst add = function(x) {\n  return function(y) {\n    return function(z) {\n      return x + y + z\n    }\n  }\n}\n\nconsole.log(add(1)(2)(3)) // 6\nconsole.log(add(1)) // function (y) {...}\n```\n\n## 高阶组件（属性代理）\n\n> HOC(全称 `Higher-order component`)是一种 React 的进阶使用方法，主要还是为了便于组件的复用。HOC 就是一个方法，获取一个组件，返回一个更高级的组件。\n\n以下是简单实现的 hoc:\n\n```js\nconst Hoc = WrappedComponent =>\n  class extends Component {\n    render() {\n      return <WrappedComponent {...this.props} name={\'guodada\'} />\n    }\n  }\n\n// use\nconst Demo = props => <span>{props.name}</span>\nexport default Hoc(Demo)\n```\n\n### hoc 的具体用途\n\n1. 代码复用\n2. 对 props 进行增删改、监控\n3. 渲染劫持\n\n其实，除了代码复用和模块化，`HOC` 做的其实就是劫持，由于传入的 `wrappedComponent` 是作为一个 `child` 进行渲染的，上级传入的 props 都是直接传给 `HOC` 的，所以 `HOC` 组件拥有很大的权限去修改 `props` 和控制渲染。\n\n对 props 进行增加上式代码用例已经说明了，我们可以使用 `HOC` 的特性来做一些渲染劫持的事情。譬如，控制组件的渲染：\n\n```js\n// 在传入的 data 未加载完时，显示 loading...\nconst Hoc = WrappedComponent =>\n  class extends Component {\n    render() {\n      if (!this.props.data) return <div>Loading...</div>\n      return <WrappedComponent {...this.props} />\n    }\n  }\n```\n\n又或者我们可以对 props 进行监控\n\n```jsx\nconst Hoc = WrappedComponent =>\n  class extends Component {\n    componentDidUpdate(prevProps, prevState) {\n      console.log(\'prevProps\', prevProps)\n      console.log(\'nextProps\', this.props)\n    }\n    render() {\n      return <WrappedComponent {...this.props} />\n    }\n  }\n```\n\n除此外还可以用来做页面权限管理。可以通过 HOC 对组件进行包裹，当跳转到当前页面的时候，检查用户是否含有对应的权限。如果有的话，渲染页面。如果没有的话，跳转到其他页面(比如无权限页面，或者登陆页面)。\n\n### 使用 HOC 注意项\n\n1. ref 不能获取到你想要获取的 ref\n\n```js\nconst Hoc = WrappedComponent =>\n  class extends Component {\n    state = { name: \'hoc\' }\n    render() {\n      return <WrappedComponent {...this.props} />\n    }\n  }\n\nclass Demo extends Component {\n  state = { name: \'guodada\' }\n  render() {\n    return null\n  }\n}\n\nconst Test = Hoc(Demo)\n\nclass App extends Component {\n  componentDidMount() {\n    console.log(this.demoRef.state) // { name: \'hoc\' }, this.demoRef 不是 Demo 组件的实例 而是 hoc 的实例对象\n  }\n\n  render() {\n    return <Test ref={node => (this.demoRef = node)} />\n  }\n}\n```\n\n2. `Component` 上面绑定的 `Static` 方法会丢失\n\n```jsx\n// 定义一个static方法\nWrappedComponent.staticMethod = function() {\n  /*...*/\n}\n// 利用HOC包裹\nconst EnhancedComponent = enhance(WrappedComponent)\n\n// 返回的方法无法获取到staticMethod\ntypeof EnhancedComponent.staticMethod === \'undefined\' // true\n```\n\n这里有一个解决方法，就是 `hoist-non-react-statics` 组件，这个组件会自动把所有绑定在对象上的非 `React` 方法都绑定到新的对象上：\n\n### 做点小运用\n\n使用 HOC 来代理用户的一些表单行为，如下：\n\n```jsx\nimport React, { Component } from \'react\'\n\nconst Form = WrappedComponent =>\n  class extends Component {\n    state = { fields: {} }\n\n    onChange = key => e => {\n      let { fields } = this.state\n      fields[key] = e.target.value\n      this.setState({ fields })\n    }\n\n    getField = fieldName => ({\n      onChange: this.onChange(fieldName)\n    })\n\n    submit = () => {\n      console.log(this.state.fields)\n    }\n\n    render() {\n      const props = {\n        ...this.props,\n        onChange: this.onChange,\n        getField: this.getField,\n        submit: this.submit\n      }\n      return <WrappedComponent {...props} />\n    }\n  }\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <input type=\"text\" {...this.props.getField(\'name\')} />\n        <button onClick={this.props.submit}>submit</button>\n      </div>\n    )\n  }\n}\n\nexport default Form(App)\n```\n\n## 高阶组件（反继承）\n\n反向继承(`Inheritance Inversion`)，简称 `II`，跟属性代理的方式不同的是，`II` 采用通过 去继承 `WrappedComponent`，本来是一种嵌套的关系，结果 `II` 返回的组件却继承了 `WrappedComponent`，这看起来是一种反转的关系。\n\n简单来理解，代理模式来自上下级组件的包装，而反继承模式的 HOC 和被包装的组件属于同级组件，可以互相调用彼此的方法和 state。而且可以劫持生命周期。\n\n使用了该模式之后两者可以视为同一组件去使用，譬如 `II` 可以调用包装的组件的方法和属性，组件可以调用 `II` 的方法和属性：\n\n```js\nimport React, { Component } from \'react\'\n\nconst Hoc = WrappedComponent =>\n  class extends WrappedComponent {\n    constructor(props) {\n      super(props)\n      this.state = {\n        theme: \'green\', // 公用属性\n        ...this.state // 组件内的属性可以覆盖 hoc 定义的属性\n      }\n    }\n\n    componentDidMount() {\n      console.log(\'run hoc componentDidMount\') // run hoc componentDidMount\n    }\n\n    toggle = () => {\n      this.setState(\n        prevState => ({\n          theme: prevState.theme === \'green\' ? \'red\' : \'green\'\n        }),\n        () => {\n          this.log(this.state.theme)\n        }\n      )\n    }\n\n    render() {\n      return super.render()\n    }\n  }\n\nclass App extends Component {\n  componentDidMount() {\n    console.log(\'run App componentDidMount\') // 不执行，因为被 hoc 劫持了\n  }\n\n  log = theme => {\n    console.log(theme)\n  }\n\n  render() {\n    return (\n      <div>\n        <div>{this.state.theme}</div>\n        <button onClick={this.toggle}>click</button>\n      </div>\n    )\n  }\n}\n\nexport default Hoc(App)\n```\n', '2019-02-11 12:27:18', '2019-02-23 04:26:52',8);
INSERT INTO `article` VALUES (9, 'react - hooks(v16.7)', '## 前言\n\n本文不做概念性的解析，旨在实操 `hooks`，相关资源可以自行谷歌。以下提供相关参考资料：\n\n- [Introducing Hooks](https://reactjs.org/docs/hooks-intro.html)\n- [理解 React Hooks](https://juejin.im/post/5be409696fb9a049b13db042)\n- [React Hooks 实用指南](https://juejin.im/post/5bffc271e51d454dca3547b1#heading-0) - 大都借鉴这篇文章\n- [Hooks 一览](https://juejin.im/post/5bd53d6a51882528382d8108)\n\n<!--more-->\n\n## useState\n\n> `useState` 可以让您的函数组件也具备类组件的 `state` 功能。\n\n```js\n/**\n * @state - state的值\n * @setState - 更新state的函数, 接受一个参数值来更新 state\n */\nconst [state, setState] = useState(initialState)\n```\n\n### 案例\n\n```js\nimport React, { useState } from \'react\'\n\nfunction Base() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n\nexport default Base\n```\n\n值得注意的是，`state` 是对象的话， `setState` 接收什么参数，就更新对象下的所有属性，而不是更新单个属性。\n\n```js\nimport React, { useState } from \'react\'\n\nfunction Demo2() {\n  const [info, setInfo] = useState({\n    name: \'guodada\',\n    age: 22\n  })\n\n  return (\n    <div>\n      <p>name: {info.name}</p>\n      <p>age: {info.age}</p>\n      <button onClick={() => setInfo({ name: \'Sam\' })}>setInfo</button>\n    </div>\n  )\n}\n```\n\n`click button` => `info = { name: \'Sam\' }`，`age` 丢失。\n\n根据业务需求，我们可以在函数组件中使用多个 `useState`，这里不再进行演示。\n\n## useEffect\n\n`Effect Hook`: 它与 `React Class` 中的 `componentDidMount`，`componentDidUpdate` 和 `componentWillUnmount` 具有相同的用途。模拟的是生命周期\n\n```js\n/**\n * @didUpdate - function\n * @[] - 参数2为数组，不加参数或者不写的话任何state 的变化都会执行 didUpdate 函数\n */\nuseEffect(didUpdate, [])\n```\n\n### 案例\n\n```js\nclass Example extends React.Component {\n  state = { count: 0 }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n等同于\n\n```js\nimport { useState, useEffect } from \'react\'\n\nfunction Example() {\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`\n  })\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n```\n\n- 添加第二个参数进行控制\n```js\nimport React, { useState, useEffect } from \'react\'\n\nfunction Example() {\n  const [count, setCount] = useState(0)\n  const [count2, setCount2] = useState(0)\n\n  useEffect(() => {\n    console.log(\'run useEffect\')\n  }, [count])  // 只有count 变化时才执行这个 useEffect 函数\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n      <p>You clicked {count2} times</p>\n      <button onClick={() => setCount2(count2 + 1)}>Click me</button>\n    </div>\n  )\n}\n```\n\n## useContext\n\n> `useReducer` 是 `useState` 的代提方案。当你有一些更负责的数据时可以使用它。（组件本地的redux）\n\n使用语法如下：\n\n```js\n/**\n * @state => your state\n * @dispatch\n *  @param {state} \n *  @param {action}  \n **/\nconst [state, dispatch] = useReducer(reducer, initialState)\n```\n\n### 案例\n\n```js\nimport React, { Component, useReducer } from \'react\'\n\nfunction TestUseReducer() {\n  const [state, dispatch] = useReducer(\n    (state, action) => {\n      switch (action.type) {\n        case \'update\':\n          return { name: action.payload }\n        default:\n          return state\n      }\n    },\n    { name: \'\' }\n  )\n\n  const handleNameChange = e => {\n    dispatch({ type: \'update\', payload: e.target.value })\n  }\n\n  return (\n    <div>\n      <p>你好：{state.name}</p>\n      <input onChange={handleNameChange} />\n    </div>\n  )\n}\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <h1>Hello</h1>\n        <h2>Start editing to see some magic happen!</h2>\n        <TestUseReducer />\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n## useCallback\n\n> `useCallback` 和 `useMemo` 有些相似。它接收一个内联函数和一个数组，它返回的是一个记忆化版本的函数。\n\n使用语法如下：\n\n```jsx\nconst memoizedValue = useMemo(() => computeExpensiveValue(a), [a])\n```\n\n### 案例\n\n```jsx\nimport React, { Component, useCallback } from \'react\'\n\nfunction TestUseCallback({ num }) {\n  const memoizedCallback = useCallback(\n    () => {\n      console.log(\'这里监听 num 值的更新重新做一些操作和计算\')\n      num.forEach(item => item++ )\n      return num\n    },\n    [num]\n  )\n  console.log(\'记忆 num > \', memoizedCallback())\n  console.log(\'原始 num > \', num)\n  return null\n}\n\nconst num1 = [1, 2, 3]\nconst num2 = [4, 5, 6]\n\nclass App extends Component {\n  state = { num: num1, count: 0 }\n\n  componentDidMount() {\n    setInterval(() => {\n      this.setState(state => ({\n        count: state.count + 1\n      }))\n    }, 3000)\n  }\n\n  handleChangeNum = () => {\n    this.setState({ num: num2 })\n  }\n\n  render() {\n    const { num } = this.state\n\n    return (\n      <div className=\"App\">\n        <h1>Hello</h1>\n        <h2>Start editing to see some magic happen!</h2>\n        <button onClick={this.handleChangeNum}>修改传入的Num值</button>\n        <TestUseCallback num={num} />\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n## useRef\n\n```js\nimport React, { useRef } from \'react\'\n\nfunction TestUseRef() {\n  const inputEl = useRef(null)\n  \n  const onButtonClick = () => {\n    inputEl.current.focus() // 设置useRef返回对象的值\n  }\n\n  return (\n    <div>\n      <p>TestUseRef</p>\n      <div>\n        <input ref={inputEl} type=\"text\" />\n        <button onClick={onButtonClick}>input聚焦</button>\n      </div>\n    </div>\n  )\n}\n\nexport default TestUseRef\n```', '2019-02-11 12:27:48', '2019-02-23 04:26:30',9);
INSERT INTO `article` VALUES (10, 'react - lazy(v16.6)', '## 动态 import\n\n在 [Code-Splitting](https://reactjs.org/docs/code-splitting.html#import) 部分，提出拆分组件的最佳方式（best way） 是使用动态的 import 方式。\n\n比如下面两种使用方式的对比：\n\n```js\n// 之前\nimport { add } from \'./math\'\n\nconsole.log(add(16, 26))\n\n// 之后\nimport(\'./math\').then(math => {\n  console.log(math.add(16, 26))\n})\n```\n\n可以发现动态 `import` 提供了 `Promise` 规范的 API，比如 `.then()`\n\n<!--more-->\n\n## demo\n\n动态 `import` 主要应用场景是延迟加载方法，对于组件来说，并不是很适用，但是 `React.lazy` 对于组件的加载则是有比较大的帮助。\n\n> `React.lazy` 和 `suspense` 并不适用于服务端渲染\n\n```jsx\nimport React, { Component, lazy, Suspense } from \'react\'\n\nconst MyComponent = lazy(() => import(\'./MyComponent\'))\n\nclass App extends Component {\n  render() {\n    // lazy 需要配合 Suspense 使用\n    // Suspense 使用的时候，fallback 一定是存在且有内容的， 否则会报错。\n    return (\n      <Suspense fallback={<div>Loading...</div>}>\n        <MyComponent />\n      </Suspense>\n    )\n  }\n}\nexport default App\n```\n\n## 实现 lazy-load\n\n```jsx\nimport React from \'react\'\nimport NProgress from \'nprogress\'\n\nexport default loadComponent =>\n  class AsyncComponent extends React.Component {\n    state = { Component: null }\n\n    async componentDidMount() {\n      if (this.state.Component !== null) return\n      NProgress.start()\n      try {\n        const { default: Component } = await loadComponent()\n        this.setState({ Component })\n      } catch (err) {\n        console.error(`Cannot load component in <AsyncComponent />`)\n        throw err\n      }\n      NProgress.done()\n    }\n\n    render() {\n      const { Component } = this.state\n      return Component ? <Component {...this.props} /> : null\n    }\n  }\n```\n\n## react-loadable （router4 推荐）\n\n[react-router - [译] Code Splitting](https://gershonv.github.io/2018/11/07/react-router-3/)\n\n```jsx\nimport React, { Component } from \'react\'\nimport { BrowserRouter as Router, Route, Switch } from \'react-router-dom\'\nimport Loadable from \'react-loadable\'\n\nconst NoFound = Loadable({\n  loader: () => import(\'./components/NoFound\'),\n  loading: <div>loading</div>\n})\n\nclass App extends Component {\n  render() {\n    return (\n      <Router>\n        <Switch>\n          <Route exact path=\"/\" component={() => <h2>Home</h2>} />\n          <Route component={NoFound} />\n        </Switch>\n      </Router>\n    )\n  }\n}\nexport default App\n```', '2019-02-11 12:28:14', '2019-02-23 04:26:08',10);
INSERT INTO `article` VALUES (11, 'react - 生命周期', '## v16.3+\n\n- Mounting\n  - constructor(props)\n  - static getDerivedStateFromProps(props, state)\n  - render()\n  - componentDidMount()\n- Updating\n  - static getDerivedStateFromProps()\n  - shouldComponentUpdate(nextProps, nextState)\n  - render()\n  - getSnapshotBeforeUpdate(prevProps, prevState)\n  - componentDidUpdate(prevProps, prevState, snapshot)\n\n<!--more-->\n\n### constructor(props)\n\nReact 组件的构造函数在安装之前被调用。在为 React.Component 子类实现构造函数时，应该在任何其他语句之前调用 `super(props)`。\n否则，`this.props` 将在构造函数中未定义，这可能导致错误。\n\nAvoid copying props into state! This is a common mistake:\n\n```js\nconstructor(props) {\n super(props)\n // Don\'t do this!\n this.state = { color: props.color }\n}\n```\n\n### static getDerivedStateFromProps(nextProps, prevState)\n\n`props / state` 改变时触发，需要返回一个对象或者 `null`，相当于 `setState`\n\n- demo\n\n```js\nstatic getDerivedStateFromProps(nextProps, prevState){\n  if (nextProps.sum !== prevState.sum) return { sum: nextProps.sum } // 类似于 setState({ sum: nextProps.sum })\n  return null\n}\n```\n\n### render()\n\n```js\nrender(){\n  // don\'t do this\n  this.setState({ num: 12 })\n  return null\n}\n\n```\n\n### componentDidMount()\n\n组件挂载后。\n\n### shouldComponentUpdate(nextProps, nextState)\n\n```js\nshouldComponentUpdate(nextProps, nextState)\n```\n\nreturn true / false 来决定是否重新 render\n\n### getSnapshotBeforeUpdate(prevProps, prevState)\n\n相当于 `componentWillUpdate`\n\n### componentDidUpdate(prevProps, prevState, snapshot)\n\n更新后 - 这里谨慎使用 setState()\n\n## v16.3 以下\n\n```jsx\nimport React, { Component } from \'react\'\n\n/**\n *\n * 挂载数据：\n * @example constructor => componentWillMount => render => componentDidMount\n *\n * 数据变化：\n * @example props change: componentWillReceiveProps => shouldComponentUpdate => componentWillUpdate => render => componentDidUpdate\n * @example state change: shouldComponentUpdate => componentWillUpdate => componentDidUpdate\n *\n */\nclass LifeCycle extends React.Component {\n  constructor() {\n    super() // 声明constructor时必须调用super方法\n    this.state = {\n      subNum: 2\n    }\n    console.log(\'01 constructor\')\n  }\n\n  componentWillMount() {\n    console.log(\'02 componentWillMount\')\n  }\n\n  componentDidMount() {\n    console.log(\'04 componentDidMount\')\n  }\n\n  componentWillReceiveProps(nextProps) {\n    console.log(\'05 componentWillReceiveProps\')\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(\'06 shouldComponentUpdate\')\n    return true // 记得要返回true\n  }\n\n  componentWillUpdate(nextProps, nextState) {\n    console.log(\'07 componentWillUpdate\')\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    console.log(\'08 componentDidUpdate\')\n  }\n\n  componentWillUnmount() {\n    console.log(\'09 componentWillUnmount\')\n  }\n\n  changeState = () => {\n    this.setState(prevState => ({\n      subNum: ++prevState.subNum\n    }))\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.changeState}>change state</button>\n        <h2>{this.state.subNum}</h2>\n      </div>\n    )\n  }\n}\n\nclass App extends Component {\n  state = {\n    num: 1\n  }\n\n  changeProps = () => {\n    // this.setState((prevState, props) => ({}))\n    this.setState(prevState => ({\n      num: ++prevState.num\n    }))\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.changeProps}>change props</button>\n        <hr />\n        <LifeCycle num={this.state.num} />\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n', '2019-02-11 12:28:32', '2019-02-23 04:25:54',11);
INSERT INTO `article` VALUES (12, 'react - Portals', '`Portals` 指定挂载组件到某个节点，适用于 `modal`、`toolTip`...\n\n我们不希望 `modal` 组件的节点出现在 `root` 根节点中。。。。\n\n```js\nReactDOM.createPortal(child, container)\n```\n\n- `child` : The first argument (child) is any renderable React child，such as an element, string, or fragment\n  即可渲染的 react 组件\n- `container` : a DOM element\n\n<!--more-->\n\n## 用法\n\n通常，如果你的组件的 render 方法返回一个元素时，它作为最接近的父节点的子节点挂载到 DOM 中：\n\n```jsx\nrender() {\n  // React mounts a new div and renders the children into it\n  return (\n    <div>\n      {this.props.children}\n    </div>\n  )\n}\n```\n\n但是，有时候要把子节点插入 DOM 中的不同位置时，是有用的：\n\n```jsx\nrender() {\n  // React does *not* create a new div. It renders the children into `domNode`.\n  // `domNode` is any valid DOM node, regardless of its location in the DOM.\n  return ReactDOM.createPortal(\n    this.props.children,\n    domNode,\n  )\n}\n```\n\n使用 `portals` 的典型场景是如果一个父组件有一个 `overflow:hidden` 或者是 `z-index` 的样式，但是你需要子节点在视觉上 `break out` （打破）这个父容器，比如 对话框，选项卡或者提示工具等\n\n下面代码实现一个 `model` 组件\n\n## App.jsx\n\n```jsx\nimport React, { Component } from \'react\'\n\nimport Modal from \'./Modal\'\n\nclass App extends Component {\n  state = { show: false }\n\n  showModal = () => {\n    this.setState({ show: !this.state.show })\n  }\n\n  closeModal = () => {\n    this.setState({ show: false })\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <button onClick={() => this.setState({ show: true })}>open Modal</button>\n\n        <Modal show={this.state.show} onClose={this.closeModal}>\n          This message is from Modal\n        </Modal>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n## Modal.jsx\n\n```jsx\nimport React, { Component } from \'react\'\nimport ReactDOM from \'react-dom\'\n\nconst backdropStyle = {\n  position: \'fixed\',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  backgroundColor: \'rgba(0, 0, 0, 0.3)\',\n  padding: 50\n}\n\nconst modalStyle = {\n  backgroundColor: \'#fff\',\n  borderRadius: 5,\n  border: \'1px solid #eee\',\n  maxWidth: 500,\n  minHeight: 300,\n  maring: \'0 auto\',\n  padding: 30,\n  position: \'relative\'\n}\n\nconst footerStyle = {\n  position: \'absolute\',\n  bottom: 20\n}\n\n// 在此前，页面需要创建一个 dom 元素 其中 id 为modal-root\nconst modalRoot = document.getElementById(\'modal-root\')\n\nclass Modal extends Component {\n  constructor(props) {\n    super(props)\n    this.el = document.createElement(\'div\')\n  }\n\n  onKeyUp = e => {\n    // 鼠标信息 http://keycode.info/\n    // 按下 esc\n    if (e.which === 27 && this.props.show) {\n      this.props.onClose()\n    }\n  }\n\n  componentDidMount() {\n    document.addEventListener(\'keyup\', this.onKeyUp)\n    modalRoot.appendChild(this.el)\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\'keyup\', this.onKeyUp)\n    modalRoot.removeChild(this.el)\n  }\n\n  render() {\n    if (!this.props.show) return null\n\n    const modalUI = (\n      <div style={backdropStyle}>\n        <div style={modalStyle}>\n          {this.props.children}\n\n          <div style={footerStyle}>\n            <button onClick={this.props.onClose}>Close</button>\n          </div>\n        </div>\n      </div>\n    )\n    // createPortal 挂载到 this.el 的元素中\n    return ReactDOM.createPortal(modalUI, this.el)\n  }\n}\n\nexport default Modal\n```\n', '2019-02-11 12:28:50', '2019-02-23 04:25:35',12);
INSERT INTO `article` VALUES (13, 'react - PropTypes', '```js\nimport React, { Component } from \'react\'\nimport PropTypes from \'prop-types\'\n\nclass MyComponent extends Component {\n  // static propTypes = {} 第二种写法\n  // static defaultProps = {}\n}\n\n// default props\nMyComponent.defaultProps = {\n  name: \'Stranger\'\n}\n\nMyComponent.PropTypes = {\n  // 声明的prop可以是一个特殊的JS基础变量，默认情况下，下面都是可选的\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // 下面示例能够渲染任何元素: numbers, strings, elements ，array, fragment\n  optionalNode: PropTypes.node,\n\n  // 需要是 React 元素\n  optionalElement: PropTypes.element,\n\n  // 可以声明 prop 是某个类的示例\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // 可以声明 prop 在某个 enum 中的一个\n  optionalEnum: PropTypes.oneOf([\'News\', \'Photos\']),\n\n  // 用来验证prop对象中的每一个属性\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // 验证 prop 数组的每个子元素的类型\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // 检查 prop 对象的属性的类型\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // 用来检查 prop 对象的每个属性的类型\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // 检查 prop 是必须存在的（required）\n  requiredFunc: PropTypes.func.isRequired,\n\n  // 用来检查任意的数值都必须存在\n  requiredAny: PropTypes.any.isRequired,\n\n  // 你可以通过自定义验证器的方法来进行验证。\n  // 自定义验证器应当返回一个抛出错误的Error对象。\n  // 不要使用`console.warn`或者throw抛出错误，因为无法再 oneOfType 中使用\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        \'Invalid prop `\' + propName + \'` supplied to\' +\n        \' `\' + componentName + \'`. Validation failed.\'\n      );\n    }\n  },\n\n  // 你也可以为\'arrayOf\'和\'objectOf\'提供自定义验证器\n  // 如果验证失败，应该返回一个Error对象\n  // 数组或者对象的每一个key都会被调用这个验证器。\n  // 此验证器的前面两个参数是数组或者是对象本身以及当前遍历的index(如数组下标或对象属性key)\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        \'Invalid prop `\' + propFullName + \'` supplied to\' +\n        \' `\' + componentName + \'`. Validation failed.\'\n      );\n    }\n  })\n\n}\n```\n', '2019-02-11 12:29:15', '2019-02-23 04:25:20',13);
INSERT INTO `article` VALUES (14, 'react - PureComponent 和 memo', '## setState 数据无改变， 组件会重新 render\n\n```jsx\nimport React, { Component } from \'react\'\n\nclass MyComponent extends Component {\n  render() {\n    console.log(\'render\')\n    return null\n  }\n}\n\nclass App extends Component {\n  state = { num: 1 }\n\n  handleClick = () => {\n    this.setState({ num: 1 }) // setState 但是不改变 num\n  }\n\n  render() {\n    return (\n      <div>\n        <MyComponent num={this.state.num} />\n        <button onClick={this.handleClick}>click</button>\n      </div>\n    )\n  }\n}\nexport default App\n```\n\n点击按钮，`setState` 后 `num` 并未发生改变， 但是组件 `MyComponent` 仍然会重新渲染，这就会导致一部分性能的消耗。\n\n我们可以使用 `shouldComponentUpdate(nextProps, nextState)` 来决定组件的渲染与否，也可以使用 react 提供的两个 API\n\n<!--more-->\n\n## React.PureComponent\n\n`pure` 是纯的意思， `PureComponent` 也就是纯组件, 只要把继承类从 `Component` 换成 `PureComponent` 即可，可以减少不必要的 `render` 操作的次数，从而提高性能。\n\n`PureComponent` 主要作用于类组件，而 `memo` 主要作用于函数组件。\n\n> `React.PureComponent` 使用 `prop` 和 `state` 的浅比较来决定是否 `render` 组件。（我们就不需要在 `shouldComponentUpdate` 中写一大段代码了！）\n\n使用方法极其简单（以上面的代码为例）：\n\n```jsx\nimport React, { Component, PureComponent } from \'react\'\n\nclass MyComponent extends PureComponent {\n  render() {\n    console.log(\'render\')\n    return null\n  }\n}\n\n// ... App\n```\n\n### 注意\n\n在不可变数据类型（数组、对象等等）`PureComponent` 是不生效的！因为它的引用地址并未发生改变。做一个 demo:\n\n```jsx\nimport React, { Component, PureComponent } from \'react\'\n\nclass MyComponent extends PureComponent {\n  render() {\n    console.log(\'render\')\n    return this.props.nums\n  }\n}\n\nclass App extends Component {\n  state = { nums: [1, 2, 3] }\n\n  handleClick = () => {\n    const { nums } = this.state\n    nums.pop()\n    this.setState({ nums })\n  }\n\n  render() {\n    return (\n      <div>\n        <MyComponent nums={this.state.nums} />\n        <button onClick={this.handleClick}>click</button>\n      </div>\n    )\n  }\n}\nexport default App\n```\n\n这里无论如何点击按钮，`MyComponent` 也不会重新渲染。具体比较过程是这样的：\n\n```jsx\nclass MyComponent extends Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // nums 引用是一样的，所以 this.props.nums 等于 nextProps.nums，结果永远返回 false，组件不会重新渲染！\n    return this.props.nums !== nextProps.nums\n  }\n\n  render() {\n    console.log(\'render\')\n    return this.props.nums\n  }\n}\n```\n\n## React.memo\n\n`React.memo` 是一个高阶组件。它与 `React.PureComponent` 类似，但是对于函数组件而不是类。\n\n```jsx\nimport React, { Component, memo } from \'react\'\n\nconst MyComponent = memo(props => {\n  console.log(\'redner\')\n  return null\n})\n\n// ... App\n```\n\n如果你的函数组件在给定相同的道具的情况下呈现相同的结果，则可以 `React.memo` 通过记忆结果将其包装在一些调用中以提高性能。这意味着 `React` 将跳过渲染组件，并重用最后渲染的结果。\n\n默认情况下，它只会浅显比较 `props` 对象中的复杂对象。如果要控制比较，还可以提供自定义比较功能作为第二个参数。\n\n```jsx\nfunction MyComponent(props) {\n  /* render using props */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  return true if passing nextProps to render would return\n  the same result as passing prevProps to render,\n  otherwise return false\n  */\n}\nexport default React.memo(MyComponent, areEqual)\n```\n\n此方法仅作为性能优化存在。不要依赖它来“防止”渲染，因为这可能导致错误。\n', '2019-02-11 12:29:33', '2019-02-23 04:25:00',1);
INSERT INTO `article` VALUES (15, 'react-redux', '## rudux\n\n`redux` 运行流程图：\n![](https://user-gold-cdn.xitu.io/2018/9/12/165c9daf60abdbd6?w=638&h=479&f=jpeg&s=21322)\n\n简单概述：**click** -> **store.dispatch(action)** -> **reduer** -> **newState** -> **viewUpdate**\n\n**react-readux** 中 通过 **connect** 链接组件和 **redux** , **this.props.dispatch()** 调用\n\n后面将会讲到...\n\n`redux` 依赖包也是十分的简洁\n![](https://user-gold-cdn.xitu.io/2018/9/14/165d8c900fb1fcd4?w=280&h=295&f=png&s=14746)\n先来个`demo`\n\n<!--more-->\n\n```js\nconst redux = require(\'redux\')\nconst createStore = redux.createStore\n\nconst types = {\n  UPDATE_NAME: \'UPDATE_NAME\'\n}\n\nconst defaultStore = {\n  user: \'tom\'\n}\n\n/**\n * reducer 纯函数 接收一个state,返回一个新的state\n * @param {Object} state\n * @param {Object} action [type] 必选参数\n * @return newState\n * */\nfunction getUser(state = defaultStore, action) {\n  const { type, payload } = action\n  let res = Object.assign({}, defaultStore)\n  switch (type) {\n    case types.UPDATE_NAME:\n      res.user = payload.name\n      break\n    default:\n      return res\n  }\n  return res\n}\n\nconst store = createStore(getUser)\n\n/**\n * listener\n * */\nstore.subscribe(() => {\n  console.log(store.getState())\n})\n\n/**\n * dispatch(action) action\n * */\nstore.dispatch({\n  type: types.UPDATE_NAME,\n  payload: {\n    name: \'大帅哥\'\n  }\n})\n//@log { name: \'大帅哥\' }\n```\n\n1. 用户发出 `action` 【`store.dispatch(action)`】\n2. `Store` 自动调用 `Reducer` , 返回新的 `state` 【`let nextState = getUser(previousState, action)`】\n3. `State` 一旦有变化，`Store` 就会调用监听函数 【`store.subscribe(listener)`】\n\n运行过程如下：\n![](https://user-gold-cdn.xitu.io/2018/9/15/165d8e7f3f6d9205?w=635&h=931&f=png&s=95651)\n\n### store\n\n`Store` 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 `Store`\n常用方法：\n\n- store.dispatch() ：分发 action 较为常用\n- store.subscribe() : state 发生变化后立即执行\n- store.getState() : 获取 store 中存着的 state\n\n### createStore\n\n[createStore](https://github.com/reduxjs/redux/blob/master/src/createStore.js) 如其名，创建 `store` 下面是该方法的部分源码：\n\n```js\n/**\n * @param {Function} reducer 函数\n * @param {any} [preloadedState] The initial state\n * @param {Function} [enhancer] The store enhancer\n * @returns {Store}\n * */\nexport default function createStore(reducer, preloadedState, enhancer) {\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'undefined\') {\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== \'undefined\') {\n    if (typeof enhancer !== \'function\') {\n      throw new Error(\'Expected the enhancer to be a function.\')\n    }\n\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n  // ...\n  return {\n    dispatch, // 分发 action\n    subscribe, // 监听器\n    getState, // 获取 store 的 state 值\n    replaceReducer,\n    [$$observable]: observable // 供Redux内部使用\n  }\n}\n```\n\n- `preloadedState`: 初始化的`initialState`，第二个参数不是`Object`,而是`Function`，`createStore`会认为你忽略了`preloadedState`而传入了一个`enhancer`\n- `createStore`会返回`enhancer(createStore)(reducer, preloadedState)`的调用结果，这是常见高阶函数的调用方式。在这个调用中`enhancer`接受`createStore`作为参数，对`createStore`的能力进行增强，并返回增强后的`createStore`\n\n### dispatch(action)\n\n`diapatch` 是 store 对象的方法，主要用来分发 `action` ,\n\n> redux 规定 action 一定要包含一个 type 属性，且 type 属性也要唯一\n\ndispatch 是 store 非常核心的一个方法，也是我们在应用中最常使用的方法，下面是 dispatch 的源码 ：\n\n```js\nfunction dispatch(action) {\n  if (!isPlainObject(action)) {\n    // 校验了action是否为一个原生js对象\n    throw new Error(\'Actions must be plain objects. \' + \'Use custom middleware for async actions.\')\n  }\n\n  if (typeof action.type === \'undefined\') {\n    // action对象是否包含了必要的type字段\n    throw new Error(\'Actions may not have an undefined \"type\" property. \' + \'Have you misspelled a constant?\')\n  }\n\n  if (isDispatching) {\n    // 判断当前是否处于某个action分发过程中, 主要是为了避免在reducer中分发action\n    throw new Error(\'Reducers may not dispatch actions.\')\n  }\n\n  try {\n    isDispatching = true\n    currentState = currentReducer(currentState, action)\n  } finally {\n    isDispatching = false\n  }\n\n  const listeners = (currentListeners = nextListeners)\n  for (let i = 0; i < listeners.length; i++) {\n    const listener = listeners[i]\n    listener()\n  }\n  // 在一系列检查完毕后，若均没有问题，将当前的状态和action传给当前reducer，用于生成新的state\n  return action\n}\n```\n\n### reducer && store.replaceReducer\n\nRedux 中负责响应 action 并修改数据的角色就是`reducer`，`reducer`的本质实际上是一个函数\nreplaceReducer:\n\n```js\n/**\n * @desc 替换当前的reducer的函数\n * @param {Function}\n * @return {void}\n */\nfunction replaceReducer(nextReducer) {\n  if (typeof nextReducer !== \'function\') {\n    throw new Error(\'Expected the nextReducer to be a function.\')\n  }\n\n  currentReducer = nextReducer\n  dispatch({ type: ActionTypes.REPLACE })\n}\n```\n\nreplaceReducer 使用场景：\n\n- 当你的程序要进行代码分割的时候\n- 当你要动态的加载不同的 reducer 的时候\n- 当你要实现一个实时 reloading 机制的时候\n\n### 中间件 middleware\n\n以上介绍了 redux 的实现流的过程，应用场景无非于\n\nbutton -- click --> `disptch` -- action --> `reducer` -- newState --> `view`\n\n但是这种实现方式是基于同步的方式的，日常开发中当然少不了 http 这些异步请求，这种情况下必须等到服务器数据返回后才重新渲染 view, 显然某些时候回阻塞页面的展示。\n\n举例来说，要添加日志功能，把 `Action` 和 `State` 打印出来，可以对 store.dispatch 进行如下改造。\n\n```js\nlet next = store.dispatch\nstore.dispatch = function dispatchAndLog(action) {\n  console.log(\'dispatching\', action)\n  next(action)\n  console.log(\'next state\', store.getState())\n}\n```\n\n上面代码中，对 store.dispatch 进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。\n\n中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。\n\n### applyMiddleware\n\nRedux 提供了`applyMiddleware`来装载`middleware`：\n它是 Redux 的原生方法，**作用是将所有中间件组成一个数组，依次执行。**下面是它的源码。\n\n```js\n/**\n * @param {...Function} middlewares\n * returns {Function} A store enhancer applying the middleware\n */\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    const store = createStore(...args)\n    let dispatch = () => {\n      throw new Error(\n        `Dispatching while constructing your middleware is not allowed. ` +\n          `Other middleware would not be applied to this dispatch.`\n      )\n    }\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n所有中间件被放进了一个数组 chain，然后嵌套执行，最后执行 store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到`getState`和`dispatch`这两个方法\n\n`compose` 实际上是函数式编程中的组合，接收多个函数体并且将其组合成一个新的函数，例如`compose` 后 [fn1, fn2...] 依次从右到左嵌套执行函数 而`compose`用于`applyMiddleware` 也是为了组合中间件\n**dispatch = compose(...chain)(store.dispatch)**\n==>\n**dispatch=fn1(fn2(fn3(store.dispatch)))**\n\n```js\n/**\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n */\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n### redux-thunk\n\n上面的中间件的介绍可以知道\nredux 通过 `applyMiddleware` 来装载中间件，通过 compose 方法可以组合函数\n\n异步的问题可以通过 `redux-thunk` 解决，用法也不难 react 组件中使用相关如下：\n\n```js\n// 配置 redux 加上这个...\nimport { createStore, applyMiddleware, compose } from \'redux\'\nimport thunk from \'redux-thunk\'\n// ...\nconst store = createStore(getUser, compose(applyMiddleware(thunk)))\n\n// react 中使用\nimport { connect } from \'react-redux\'\n\nhandleClick = () => {\n  this.props.dispatch(dispatch => {\n    return axios.get(\'https://randomuser.me/api/\').then(res => {\n      dispatch({\n        type: types.CHANGE_ARRAY,\n        payload: {\n          name: res.data.results[0].name.title\n        }\n      })\n    })\n  })\n}\n\nconst mapStateToProps = (state, props) => {\n  return {\n    name: state.demo.name\n  }\n}\n\nexport default connect(mapStateToProps)(Demo)\n```\n\n> 处理异步的还有很多插件 如 redux-soga 等，楼主并未实践过，所以不做延伸...\n\n## react-redux\n\n下面是在 react 中使用的代码的雏形：\n\n```jsx\nimport { createStore } from \'redux\'\n\nlet defaultState = {\n  count: 1\n}\n\n/**\n * Reducer\n * */\nfunction demoReducer(state = defaultState, action = {}) {\n  const { type, payload } = action\n  const res = Object.assign({}, state)\n  if (type === \'changeCount\') {\n    res.count = payload.count\n  }\n  return res\n}\n\n/**\n * @Store 存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。\n * combineReducers({ ...reducers }) 可以组合多个reducer\n * */\nconst store = createStore(\n  demoReducer,\n  window.devToolsExtension && window.devToolsExtension() // 配置redux 开发工具\n)\n\n// ... 根元素下配置下 Provider\nimport { Provider } from \'react-redux\'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\'root\')\n)\n\n// 组件中使用\nimport { connect } from \'react-redux\'\n\n//use\nthis.dispatch({\n  type: \'changeCount\',\n  payload: {\n    count: 22\n  }\n})\n\nconst mapStateToProps = (state, props) => {\n  return {\n    name: state.demo.name\n  }\n}\n\nexport default connect(mapStateToProps)(Demo)\n```\n\n### mapStateToProps\n\n- 用于建立组件跟 store 的 state 的映射关系作为一个函数，它可以传入两个参数，结果一定要返回一个 object\n- 传入`mapStateToProps`之后，会订阅 store 的状态改变，在每次 store 的 state 发生变化的时候，都会被调用\n- 如果写了第二个参数 props，那么当 props 发生变化的时候，mapStateToProps 也会被调用\n\n### mapDispatchToProps\n\n- `mapDispatchToProps`用于建立组件跟 store.dispatch 的映射关系\n- 可以是一个 object，也可以传入函数\n- 如果`mapDispatchToProps`是一个函数，它可以传入 dispatch,props,定义 UI 组件如何发出 action，实际上就是要调用 dispatch 这个方法\n\n```js\nimport { connect } from \'react-redux\'\nimport { bindActionCreators } from \'redux\'\n\n// 页面中使用...\nthis.props.changeName()\n\nconst mapDispatchToProps = ({ changeName } = (dispatch, props) => {\n  return bindActionCreators(\n    {\n      changeName: function() {\n        return {\n          type: types.UPDATE_NAME,\n          payload: {\n            name: \'大大大\'\n          }\n        }\n      }\n    },\n    dispatch\n  )\n})\n\nexport default connect(mapDispatchToProps)(App)\n```\n\n## 模块化配置\n\n下面的配置仅供参考。实现的功能：\n\n- 整合 `action`、`types`、`reducer` 到一个文件\n- 根据开发/生成环境配置不同的 `redux` 中间件(开发环境配置 `dev-tools` )\n- 支持装饰器模式\n- `redux` 热加载配置（这里面顺便将 `react` 热加载配置也加上了）\n\n注意：项目基于 `create-react-app` `eject` 后的配置改造实现的。下面用了别名 @ ，需要改下 `webpack` 的配置，如果你配置不成功。详情可以看我的 `github` 上面有源码. [链接入口](https://github.com/gershonv/react-demo)\n\n### 安装\n\n```\nnpm install redux react-redux redux-thunk --save\nnpm install redux-devtools-extension react-hot-loader -D\nnpm install @babel/plugin-proposal-decorators -D\n```\n\n相关文件夹如图：\n![](https://user-gold-cdn.xitu.io/2018/12/11/1679c389904fbb55?w=368&h=300&f=png&s=16726)\n\n#### models/demo.js\n\ndemo 模块。\n\n```js\n// types\nconst ADD_COUNT = \'ADD_COUNT\'\n\n// actions\nexport const addCount = () => {\n  return { type: ADD_COUNT }\n}\n\n// state\nconst defaultState = {\n  count: 11\n}\n\n// reducer\nexport const demoReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case ADD_COUNT:\n      return { ...state, count: ++state.count }\n    default:\n      return state\n  }\n}\n\nexport default demoReducer\n```\n\n#### models/index.js\n\n模块的导出口。\n\n```js\nimport { combineReducers } from \'redux\'\n\nimport demo from \'./demo\'\n\nexport default combineReducers({\n  demo\n})\n```\n\n#### redux/index.js\n\n`redux` 仓库的总出口\n\n```js\nimport thunk from \'redux-thunk\'\nimport { compose, createStore, applyMiddleware } from \'redux\'\nimport { composeWithDevTools } from \'redux-devtools-extension\'\n\nimport rootReducer from \'./models\'\n\nlet storeEnhancers\nif (process.env.NODE_ENV === \'production\') {\n  storeEnhancers = compose(thunk)\n} else {\n  storeEnhancers = compose(composeWithDevTools(applyMiddleware(thunk)))\n}\n\nconst configureStore = (initialState = {}) => {\n  const store = createStore(rootReducer, initialState, storeEnhancers)\n\n  if (module.hot && process.env.NODE_ENV !== \'production\') {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept(\'./models\', () => {\n      console.log(\'replacing reducer...\')\n      const nextRootReducer = require(\'./models\').default\n      store.replaceReducer(nextRootReducer)\n    })\n  }\n\n  return store\n}\n\nexport default configureStore()\n```\n\n#### src/index.js\n\nreact 项目的入口配置。\n\n```js\nimport React from \'react\'\nimport ReactDOM from \'react-dom\'\nimport { AppContainer } from \'react-hot-loader\'\nimport App from \'./App\'\nimport { Provider } from \'react-redux\'\nimport store from \'@/redux\'\n\nconst render = Component => {\n  ReactDOM.render(\n    <AppContainer>\n      <Provider store={store}>\n        <Component />\n      </Provider>\n    </AppContainer>,\n    document.getElementById(\'root\')\n  )\n}\n\nrender(App)\n\nif (module.hot) {\n  module.hot.accept(\'./App\', () => {\n    render(App)\n  })\n}\n```\n\n#### App.jsx\n\n```js\nimport React, { Component, Fragment } from \'react\'\nimport { connect } from \'react-redux\'\nimport { addCount } from \'@/redux/models/demo\'\nimport { Button } from \'antd\'\n\nconst mapStateToProps = state => ({\n  count: state.demo.count\n})\n\n@connect(\n  mapStateToProps,\n  { addCount }\n)\nclass ReduxTest extends Component {\n  render() {\n    return (\n      <Fragment>\n        {this.props.count}\n        <Button type=\"primary\" onClick={this.props.addCount}>\n          Click\n        </Button>\n        <hr />\n      </Fragment>\n    )\n  }\n}\n\nexport default ReduxTest\n```\n\n#### .babelrc\n\n配置 babel 装饰器模式\n\n```js\n{\n  \"presets\": [\"react-app\"],\n  \"plugins\": [\n    [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }]\n  ]\n}\n```\n\nvscode 装饰器模式如果有报警的话，可以根目录下新建 `jsconfig.json`\n\n```js\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\n        \"src/*\"\n      ]\n    },\n    \"jsx\": \"react\"\n  },\n  \"exclude\": [\n    \"node_modules\",\n    \"build\",\n    \"config\",\n    \"scripts\"\n  ]\n}\n```\n\n## 参考\n\n- [阮一峰 redux 入门教程](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)\n- 配置文件可以看我的 github : [react-demo](https://github.com/gershonv/react-demo)', '2019-02-11 12:31:15', '2019-02-11 12:31:15',2);
INSERT INTO `article` VALUES (16, 'react - Ref', '在 `react` 典型的数据流中，`props` 传递是父子组件交互的唯一方式；要修改子组件，你需要使用新的 props 重新渲染它。\n但是，某些情况下你需要在典型数据流外强制修改子组件。某些情况下（例如和第三方的 dom 库整合，或者某个 dom 元素 focus 等）为了修改子组件我们可能需要另一种方式，这就是 `ref` 方式。\n\n<!-- more -->\n\n## ref 简介\n\n`React` 提供的这个 `ref` 属性，表示为对组件真正实例的引用，其实就是 `ReactDOM.render()`返回的组件实例；需要区分一下，`ReactDOM.render()`渲染组件时返回的是组件实例；而渲染 `dom` 元素时，返回是具体的 `dom` 节点。\n\n> 那么我们可以知道 `ref` 挂载到普通 `dom` 节点时代表这个 `dom` 元素，相当于 `document.querySelect()`, 而挂载到组件时返回的是这个组件的实例（我们可以直接访问组件的 `state` 和方法）\n\n```js\nclass Demo extends Component {\n  state = { name: \'demo\' }\n  render() {\n    return null\n  }\n}\n\nclass App extends Component {\n  componentDidMount() {\n    this.input.focus() // 控制 input 元素的聚焦\n    console.log(this.demo.state) // { name: \'demo\' }\n  }\n\n  render() {\n    return (\n      <div>\n        <input type=\"text\" ref={el => (this.input = el)} />\n        <Demo ref={el => (this.demo = el)} />\n      </div>\n    )\n  }\n}\n```\n\n## 通过回调方式设置 ref（推荐）\n\nref 属性可以设置为一个回调函数，这也是官方强烈推荐的用法；这个函数执行的时机为：\n\n- 组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例。\n- 组件被卸载或者原有的 `ref` 属性本身发生变化时，回调也会被立即执行，此时回调函数参数为 `null`，以确保内存泄露。\n\n```js\nclass Demo extends Component {\n  render() {\n    return <span>demo</span>\n  }\n}\n\nclass App extends Component {\n  state = { visible: true }\n\n  toggleVisible = () => {\n    this.setState({ visible: !this.state.visible })\n  }\n\n  refCb = instance => {\n    console.log(instance)\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.toggleVisible}>toggle</button>\n        {this.state.visible && <Demo ref={this.refCb} />}\n      </div>\n    )\n  }\n}\n// demo mounted => run refCb 返回 Demo 组件实例对象\n// demo destory => run refCb 返回 null\n```\n\n## 其他方式设置 ref\n\n### createRef\n\n```js\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.inputRef = React.createRef()\n  }\n\n  componentDidMount() {\n    this.inputRef.current.focus()\n  }\n\n  render() {\n    return <input type=\"text\" ref={this.inputRef} />\n  }\n}\n```\n\n### ref=\'xxx\'（不推荐）\n\n```jsx\n<input ref=\"inputRef\" />\n\n// this.refs.inputRef 访问这个 dom 元素\n```\n\n## 在函数组件中使用 ref\n\n函数组件，即无状态组件`stateless component`在创建时是不会被实例化的。\n无状态组件内部其实是可以使用 ref 功能的，虽然不能通过 this.refs 访问到，但是可以通过将 ref 内容保存到无状态组件内部的一个本地变量中获取到。\n\n```jsx\nimport React from \'react\'\n\nconst App = () => {\n  let inputRef\n  function handleClick() {\n    inputRef.focus()\n  }\n  return (\n    <div>\n      <button onClick={handleClick}>focus</button>\n      <input type=\"text\" ref={el => (inputRef = el)} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n## React.forwardRef\n\n> `Ref forwarding` 是一种自动将 `ref` 通过组件传递给其子节点的技术。\n\nRef 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref。也就是说我们不想控制子组件，我们想具体控制到子组件某个组件的实例。\n\n```js\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.children}\n  </button>\n))\n\nclass App extends Component {\n  componentDidMount() {\n    console.log(this.fButton) //  <button className=\"FancyButton\">click</button>\n  }\n\n  render() {\n    return <FancyButton ref={node => (this.fButton = node)}>click</FancyButton>\n  }\n}\n```\n\n举例个应用场景，我们自封装一个 `Input` 组件，那我们的 `ref` 是要具体控制到原生的 `input`。以下是具体得代码：\n\n```js\nclass Input extends Component {\n  render() {\n    const { forwardedRef, ...rest } = this.props\n    return <input {...rest} ref={forwardedRef} type=\"text\" />\n  }\n}\n\nconst MyInput = React.forwardRef((props, ref) => <Input {...props} forwardedRef={ref} />)\n\nclass App extends Component {\n  componentDidMount() {\n    this.input.focus()\n  }\n\n  render() {\n    return <MyInput defaultValue=\"guodada\" ref={el => (this.input = el)} />\n  }\n}\n```\n\n## ref 在 HOC 中存在的问题\n\n`react` 的 HOC 是高阶组件，简单理解就是包装了一个低阶的组件，最后返回一个高阶的组件；高阶组件其实是在低阶组件基础上做了一些事情。\n\n既然 `HOC` 会基于低阶组件生成一个新的高阶组件，若用 `ref` 就不能访问到我们真正需要的低阶组件实例，我们访问到的其实是高阶组件实例。所以:\n\n```js\nconst Hoc = WrappedComponent =>\n  class extends Component {\n    render() {\n      return <WrappedComponent {...this.props} />\n    }\n  }\n\nclass Demo extends Component {\n  state = { name: \'guodada\' }\n  render() {\n    return null\n  }\n}\n\nconst Test = Hoc(Demo)\n\nclass App extends Component {\n  componentDidMount() {\n    console.log(this.demoRef.state) // null, this.demoRef 不是 Demo 组件的实例\n  }\n\n  render() {\n    return <Test ref={node => (this.demoRef = node)} />\n  }\n}\n```\n\n## 总结\n\n`ref` 提供了一种对于 `react` 标准的数据流不太适用的情况下组件间交互的方式，例如管理 dom 元素 focus、text selection 以及与第三方的 dom 库整合等等。 但是在大多数情况下应该使用 react 响应数据流那种方式，不要过度使用 ref。\n\n另外，在使用 ref 时，不用担心会导致内存泄露的问题，react 会自动帮你管理好，在组件卸载时 ref 值也会被销毁。\n\n最后补充一点：\n\n> 不要在组件的 `render` 方法中访问 `ref` 引用，`render` 方法只是返回一个虚拟 dom，这时组件不一定挂载到 `dom` 中或者 `render` 返回的虚拟 dom 不一定会更新到 dom 中。\n\n参考 [React 之 ref 详细用法](https://segmentfault.com/a/1190000008665915)\n', '2019-02-11 12:31:48', '2019-02-11 12:31:48',3);
INSERT INTO `article` VALUES (17, 'react-router - [译] quickstart', '## Quick start - 快速开始\n\n```jsx\nimport React from \'react\'\nimport { BrowserRouter as Router, Route, Link } from \'react-router-dom\'\n\nconst Index = () => <h2>Home</h2>\nconst About = () => <h2>About</h2>\nconst Users = () => <h2>Users</h2>\n\nconst AppRouter = () => (\n  <Router>\n    <div>\n      <nav>\n        <ul>\n          <Link to=\"/\">Home</Link>\n          <Link to=\"/about/\">About</Link>\n          <Link to=\"/users/\">Users</Link>\n        </ul>\n      </nav>\n\n      <Route path=\"/\" exact component={Index} />\n      <Route path=\"/about/\" component={About} />\n      <Route path=\"/users/\" component={Users} />\n    </div>\n  </Router>\n)\n\nexport default AppRouter\n```\n<!--more-->\n\n## Nested Routing -嵌套路由\n\n```jsx\nimport React from \'react\'\nimport { BrowserRouter as Router, Route, Link } from \'react-router-dom\'\n\nconst App = () => (\n  <Router>\n    <div>\n      <nav>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about/\">About</Link>\n        <Link to=\"/topics\">Topics</Link>\n      </nav>\n\n      <Route exact path=\"/\" component={Home} />\n      <Route path=\"/about\" component={About} />\n      <Route path=\"/topics\" component={Topics} />\n    </div>\n  </Router>\n)\n\nconst Home = () => <h2>Home</h2>\nconst About = () => <h2>About</h2>\n\n/**\n * @param props\n * Route 组件中 component 的 props 中会传递 match 属性\n * @example /topics/components\n *          match `isExact`: true ; `params`: {id: \"components\"} ; `path`: \"/topics/:id\"; `url`: \"/topics/components\"\n */\nconst Topic = ({ match }) => <h3>Requested Param: {match.params.id}</h3>\n\n\nconst Topics = ({ match }) => (\n  <div>\n    <h2>Topics</h2>\n    <Link to={`${match.url}/components`}>Components</Link>\n    <Link to={`${match.url}/props-v-state`}>Props v. State</Link>\n    <Route path={`${match.path}/:id`} component={Topic} />\n    <Route\n      exact\n      path={match.path}\n      render={() => <h3>Please select a topic.</h3>}\n    />\n  </div>\n)\n\nexport default App\n```', '2019-02-11 12:37:48', '2019-02-20 05:44:12',1);
INSERT INTO `article` VALUES (65, 'webpack - 理论篇', '# entry\n\n```js\n/**\n * @param {String} - String 时 打包为一个文件，默认包名 main.js\n * @param {Array} - Array 时 webpack会把数组里所有文件打包成一个js文件\n * @param {Object} - Object 时 webpack会把对象里的文件分别打包成多个文件\n *\n */\nmodule.exports = {\n  entry: \'./index.js\',\n\n  entry: [\'./index.js\', \'./about.js\'],\n\n  entry: {\n    app: \'./index.js\',\n    about: \'./about.js\'\n  },\n\n  entry: {\n    app: \'./index.js\',\n    vendors: [\'jquery\'] // 分离第三方库\n  }\n}\n```\n<!--more-->\n\n### vendors 第三方库\n\n// 待补充\n\n## output\n\n> 指示 webpack 如何去输出、以及在哪里输出、输出的格式等\n\n```js\nmodule.exports = {\n  output: {\n    path: path.resolve(__dirname, \'dist\'), // 输出文件的目录\n    filename: \'js/[name].[chunkhash:8].js\', // 打包路径及名称\n    chunkFilename: \'js/[name].[chunkhash:8].js\' // 按需加载\n    // publicPath：文件输出的公共路径，\n    //...\n  }\n}\n```\n\n## resolve\n\n> 配置模块如何解析\n\n- `extensions`：自动解析确定的扩展,省去你引入组件时写后缀的麻烦，\n- `alias`：非常重要的一个配置，它可以配置一些短路径，\n- `modules`：webpack 解析模块时应该搜索的目录，\n- ...\n\n```js\nmodule.exports = {\n  resolve: {\n    extensions: [\'.js\', \'.jsx\', \'.ts\', \'.tsx\', \'.scss\', \'.json\', \'.css\'],\n    alias: {\n      \'@\': path.resolve(__dirname, \'src\')\n    },\n    modules: [path.resolve(__dirname, \'src\'), \'node_modules\']\n  }\n}\n```\n\n## module.rules\n\n- `rules`：也就是之前的 loaders，\n- `test` ： 正则表达式，匹配编译的文件，\n- `exclude`：排除特定条件，如通常会写 `node_modules`，即把某些目录/文件过滤掉，\n- `include`：它正好与 `exclude` 相反，\n- `use -loader` ：必须要有它，它相当于是一个 `test` 匹配到的文件对应的解析器，`babel-loader`、`style-loader`、`sass-loader`、`url-loader` 等等，\n- `use - options`：它与 `loader` 配合使用，可以是一个字符串或对象，它的配置可以直接简写在 `loader` 内一起，它下面还有 `presets`、`plugins` 等属性；\n\n## plugins\n\n// 另一篇文章 webpack - plugins 篇 敬请期待\n\n## devtool\n\n- 控制是否生成，以及如何生成 source map 文件，开发环境下更有利于定位问题，默认 false,\n- 当然它的开启，也会影响编译的速度，所以生产环境一定一定记得关闭；\n- 常用的值：`cheap-eval-source-map`、`eval-source-map`、`cheap-module-eval-source-map`、`inline-cheap-module-source-map` 等等\n\n```js\ndevtool: \'eval-source-map\' // 原始源代码\n```\n\n## webpack-dev-server\n\n- `contentBase` ：告诉服务(dev server)在哪里查找文件，默认不指定会在是当期项目根目录，\n- `historyApiFallback`:可以是 boolean、 object，默认响应的入口文件，包括 404 都会指向这里，object 见下面示例：\n- `compress`：启用 gzip 压缩，\n- `publicPath`：它其实就是 output.publicPath，当你改变了它，即会覆盖了 output 的配置，\n- `stats`： 可以自定控制要显示的编译细节信息，\n- `proxy`：它其实就是 http-proxy-middleware，可以进行处理一些代理的请求。\n\n```js\nconst webpack = require(\'webpack\')\n\nmodule.exports = {\n  devServer: {\n    contentBase:\'./assets\',\n    port: 1234,\n    open: true, // 自动打开浏览器\n    compress: true // 服务器压缩\n    hot: true // 配合 HotModuleReplacementPlugin 使用\n    //... proxy、hot\n  },\n  plugins: [\n    new webpack.HotModuleReplacementPlugin()\n  ]\n}\n```\n\n## optimization\n\n- `optimization` 是 `webpack4` 新增的，主要是用来让开发者根据需要自定义一些优化构建打包的策略配置，\n- `minimize`：true/false,告诉 webpack 是否开启代码最小化压缩，\n- `minimizer`：自定 js 优化配置，会覆盖默认的配置，结合 `UglifyJsPlugin` 插件使用，\n- `removeEmptyChunks`: bool 值，它检测并删除空的块。将设置为 false 将禁用此优化，\n- `nodeEnv`：它并不是 node 里的环境变量，设置后可以在代码里使用 process.env.NODE_ENV === \'development\'来判断一些逻辑，生产环境 `UglifyJsPlugin` 会自动删除无用代码，\n- `splitChunks` ：取代了 CommonsChunkPlugin，自动分包拆分、代码拆分，详细默认配置：\n- 默认配置，只会作用于异步加载的代码块 —— chunks: \'async\'，它有三个值：all,async,initial\n\n```js\nmodule.exports = {\n  // 优化构建打包的策略配置\n  optimization: {\n    minimize: true, // 是否开启代码最小化压缩 默认 false\n    //splitChunks 默认配置\n    splitChunks: {\n      chunks: \'async\',\n      minSize: 30000,\n      maxSize: 0,\n      minChunks: 1,\n      maxAsyncRequests: 5,\n      maxInitialRequests: 3,\n      automaticNameDelimiter: \'~\',\n      name: true,\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n}\n```\n\n### 配合 UglifyJsPlugin\n\n```js\nconst UglifyJsPlugin = require(\'uglifyjs-webpack-plugin\')\n\nmodule.exports = {\n  // 优化构建打包的策略配置\n  optimization: {\n    minimizer: [\n      new UglifyJsPlugin({\n        cache: true, // 开启缓存\n        parallel: true, // 开启多线程编译\n        sourceMap: true, // 是否sourceMap\n        uglifyOptions: {\n          // 丑化参数\n          comments: false,\n          warnings: false,\n          compress: {\n            unused: true,\n            dead_code: true,\n            collapse_vars: true,\n            reduce_vars: true\n          },\n          output: {\n            comments: false\n          }\n        }\n      })\n    ]\n  }\n}\n```\n\n## 参考\n\n- [webpack4 配置详解之慢嚼细咽](https://juejin.im/post/5be64a7bf265da615304493e#heading-9)\n', '2019-02-01 05:05:19', '2019-02-23 05:05:19',0);
INSERT INTO `article` VALUES (66, 'webpack - babel篇', '\n> [Babel](https://babeljs.io/docs/en/) 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 `webpack` 中配置 `Babel`，以便使用 ES6、ES7 标准来编写 JS 代码。\n\n本文以当前最新版本的 [babel - 7.10](https://babeljs.io/docs/en/) 为例， 做 `babel` 的配置. 相关版本号如下\n\n```json\n{\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.1.6\",\n    \"@babel/plugin-proposal-decorators\": \"^7.1.6\",\n    \"@babel/plugin-transform-runtime\": \"^7.1.0\",\n    \"@babel/preset-env\": \"^7.1.6\",\n    \"@babel/runtime\": \"^7.1.5\",\n    \"babel-loader\": \"^8.0.4\",\n    \"webpack\": \"^4.26.1\",\n    \"webpack-cli\": \"^3.1.2\"\n  }\n}\n```\n<!--more-->\n\n## babel-loader 和 @babel/core\n\n建立基本的 `webpack` 配置文件\n\n```js\nmkdir webpack-babel => cd  webpack-babel => yarn init -y  // 初始化\nnpm i yarn -g // 安装了yarn可以忽略\nyarn add webpack webpack-cli -D\n\n// package.json 中添加：\n\"scripts\": {\n  \"start\": \"webpack --mode development\",\n  \"build\": \"webpack --mode production\"\n}\n\nyarn add babel-loader @babel/core -D\n```\n\n- [yarn](https://www.npmjs.com/package/yarn) : 和 `npm` 几乎一样，本文使用 `yarn` 安装...\n- [babel-loader](https://www.npmjs.com/package/babel-loader): 转义 js 文件代码的 loader\n- [@babel/core](https://www.npmjs.com/package/@babel/core)：babel 核心库\n\n根目录下添加 `webpack.config.js`\n\n```js\nconst path = require(\'path\')\n\nmodule.exports = {\n  entry: \'./src/index.js\',\n  output: {\n    path: path.resolve(__dirname, \'dist\'),\n    filename: \'[name].[hash:8].js\'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: { loader: \'babel-loader\' } // options 在 .babelrc 定义\n      }\n    ]\n  }\n}\n```\n\n`src/index.js`\n\n```js\nconst func = () => {\n  console.log(\'hello webpack\')\n}\nfunc()\n\nclass User {\n  constructor() {\n    console.log(\'new User\')\n  }\n}\n\nconst user = new User()\n```\n\n执行 `yarn build` 后就可以打包成功，打包后的代码是压缩后的。而 `yarn start` 后的代码是未压缩的。为了使代码可读性高一点，我们可以在`webpack.config.js`添加：\n\n```js\nmodule.exports = {\n  //...\n  devtool: true\n}\n```\n\n## @babel-preset-env\n\n打包后我们可以发现箭头函数并未转化为 `ES5` 语法！\n\n查阅 [babel plugins](https://babeljs.io/docs/en/plugins) 文档，如果要转义箭头函数，需要使用到 `@babel/plugin-transform-arrow-functions` 这个插件\n同理转义 `class` 需要使用 `@babel/plugin-transform-classes`\n\n```\nyarn add @babel/plugin-transform-arrow-functions @babel/plugin-transform-classes -D\n```\n\n根目录下建立 `.babelrc` 文件：\n\n```js\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-arrow-functions\",\n    \"@babel/plugin-transform-classes\"\n  ]\n}\n```\n\n`yarn build` 之后可以看出 箭头函数和类都被转义了。\n\n但是假如你再使用 `async await` 之类的 `es6` 语法，你还得一个个添加，这是不实际的。\n\n[@babel-preset-env](https://babeljs.io/docs/en/babel-preset-env#docsNav) 就整合了这些语法转义插件：\n\n```js\nUsing plugins:\ntransform-template-literals {}\ntransform-literals {}\ntransform-function-name {}\ntransform-arrow-functions {}\ntransform-block-scoped-functions {}\ntransform-classes {}\ntransform-object-super {}\n//...\n```\n\n使用如下：\n\n```\nyarn add @babel-preset-env -D\n```\n\n`.babelrc`\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\n## @babel/polyfill\n\n> Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。\n\n这样就导致了一些新的 API 老版浏览器不兼容。如上述所说，对于新的 API，你可能需要引入 `@babel-polyfill` 来进行兼容\n\n```\nyarn add @babel-polyfill -D\n```\n\n修改 `weboack.config.js`\n\n```js\nmodule.exports = {\n  entry: [\'@babel-polyfill\', \'./src/index.js\']\n}\n```\n\n`yarn build` 发现文件体积大了很多，因为上面的代码表示将 `@babel-polyfill` 的代码也打包进去了。\n\n当然这不是我们希望的，如何按需编译呢？ 我们可以这么做：\n\n`index.js`\n\n```js\nimport \'@babel/polyfill\' // 引入\n\nconst func = () => {\n  console.log(\'hello webpack\')\n}\nfunc()\n\nclass User {\n  constructor() {\n    console.log(\'new User\')\n  }\n}\n\nconst user = new User()\n\nnew Promise(resolve => console.log(\'promise\'))\n\nArray.from(\'foo\')\n```\n\n还原 `webpack.config.js`\n\n```js\nmodule.exports = {\n  entry: \'./src/index.js\'\n}\n```\n\n修改 `.babelrc`\n\n```json\n{\n  \"presets\": [[\"@babel/preset-env\", { \"useBuiltIns\": \"usage\" }]]\n}\n```\n\n`yarn build` 后发现我们的代码体积就变得很小了！\n\n## @babel/runtime 和 @babel/plugin-transform-runtime\n\n- `babel-polyfill` 会污染全局作用域, 如引入 `Array.prototype.includes` 修改了 Array 的原型，除此外还有 String...\n- `babel-polyfill` 引入新的对象： `Promise`、`WeakMap` 等\n\n这也不是我们希望出现的。\n\n- `@babel/runtime` 的作用：\n  - 提取辅助函数。ES6 转码时，babel 会需要一些辅助函数，例如 \\_extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 `babel-runtime` 中，这样做能减小项目文件的大小。\n  - 提供 `polyfill`：不会污染全局作用域，但是不支持实例方法如 Array.includes\n- `@transform-runtime` 的作用：\n  - `babel-runtime` 更像是分散的 `polyfill` 模块，需要在各自的模块里单独引入，借助 transform-runtime 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 `polyfill`，你只需使用，`transform-runtime` 会帮你引入。\n\n```\nyarn add  @babel/runtime-corejs2\nyarn add @babel/plugin-transform-runtime -D\n```\n\n修改 `.babelrc`\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [[\"@babel/plugin-transform-runtime\", { \"corejs\": 2 }]]\n}\n```\n\n`index.js` 移除 `import \'@babel/polyfill\'`\n\n## @babel/plugin-proposal-decorators\n\n添加装饰器模式的支持\n\n```\nyarn add @babel/plugin-proposal-decorators -D\n```\n\n`index.js`\n\n```js\nfunction annotation(target) {\n  target.annotated = true\n}\n\n@annotation\nclass User {\n  constructor() {\n    console.log(\'new User\')\n  }\n}\n//...\n```\n\n`.babelrc`\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\n    [\"@babel/plugin-proposal-decorators\", { \"decoratorsBeforeExport\": true }],\n    [\"@babel/plugin-transform-runtime\", { \"corejs\": 2 }]\n  ]\n}\n\n```\n', '2019-02-01 05:05:52', '2019-02-23 05:05:52',1);
INSERT INTO `article` VALUES (67, 'webpack - plugins', '## 功能类\n\n### html-webpack-plugin\n\n- 把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等\n- `filename`：输出文件名；\n- `template`：模板文件，不局限于 html 后缀哦；\n- `removeComments`：移除 HTML 中的注释；\n- `collapseWhitespace`：删除空白符与换行符，整个文件会压成一行；\n- `inlineSource`：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入；\n- `inject`：是否能注入内容到 输出 的页面去；\n- `chunks`：指定插入某些模块；\n- `hash`：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；\n  其他：favicon、meta、title ……；\n\n<!--more-->\n\n```js\nconst path = require(\'path\')\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\nmodule.exports = {\n  mode: \'production\',\n  entry: \'./src/index.js\',\n  output: {\n    path: path.resolve(__dirname, \'dist\'), // 输出文件的目录\n    filename: \'js/[name].[hash:8].js\' // 打包路径及名称\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \'index.html\', // 生成文件名\n      template: \'./public/index.html\', // 配置要被编译的html文件\n      hash: true,\n      // 压缩HTML文件\n      minify: {\n        removeAttributeQuotes: true, //删除双引号\n        collapseWhitespace: true //折叠 html 为一行\n      }\n    })\n  ]\n}\n```\n\n传送门 ==> [html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)\n\n### clean-webpack-plugin\n\n> 在编译之前清理指定目录指定内容。\n\n```js\nconst CleanWebpackPlugin = require(\'clean-webpack-plugin\')\nmodule.exports = {\n  plugins: [new CleanWebpackPlugin([\'dist\'])]\n}\n\n// 指定清除哪些文件 new CleanWebpackPlugin(pathsToClean [, {pathsToClean }]) 详情请看 npm\n```\n\n传送门 ==> [clean-webpack-plugin](https://www.npmjs.com/package/clean-webpack-plugin)\n\n### copy-webpack-plugin\n\n```js\nconst CopyWebpackPlugin = require(\'copy-webpack-plugin\')\n\nmodule.exports = {\n  plugins: [new CopyWebpackPlugin([...patterns], options)]\n}\n```\n\n传送门 ==> [copy-webpack-plugin](https://www.npmjs.com/package/copy-webpack-plugin)\n\n### compression-webpack-plugin\n\n> 使用 compression-webpack-plugin 插件进行压缩，提供带 `Content-Encoding` 编码的压缩版的资源。\n\n```js\nconst CompressionPlugin = require(\'compression-webpack-plugin\')\nmodule.exports = {\n  plugins: [\n    new CompressionPlugin({\n      filename: \'[path].gz[query]\', //目标资源名称。[file] 会被替换成原资源。[path] 会被替换成原资源路径，[query] 替换成原查询字符串\n      algorithm: \'gzip\', //算法\n      test: /\\.js(\\?.*)?$/i, //压缩 js\n      deleteOriginalAssets: true, // 删除源文件\n      threshold: 10240, //只处理比这个值大的资源。按字节计算\n      minRatio: 0.8 //只有压缩率比这个值小的资源才会被处理\n    })\n  ]\n}\n```\n\n传送门 ==> [compression-webpack-plugin](https://www.npmjs.com/package/compression-webpack-plugin)\n\n### webpack-manifest-plugin\n\n> 该插件可以显示出编译之前的文件和编译之后的文件的映射\n\n```js\nconst ManifestPlugin = require(\'webpack-manifest-plugin\')\nmodule.exports = {\n  plugins: [new ManifestPlugin()]\n}\n```\n\n传送门 ==> [webpack-manifest-plugin](https://www.npmjs.com/package/webpack-manifest-plugin)\n\n### progress-bar-webpack-plugin\n\n> 编译进度条插件\n\n```js\nconst ProgressBarPlugin = require(\'progress-bar-webpack-plugin\') // 编译进度条插件\nmodule.exports = {\n  plugins: [new ProgressBarPlugin()]\n}\n```\n\n传送门 ==> [progress-bar-webpack-plugin](https://www.npmjs.com/package/progress-bar-webpack-plugin)\n\n## 代码相关\n\n### webpack.ProvidePlugin\n\n> 自动加载模块，而不必到处 import 或 require 。\n\n```js\nconst webpack = require(\'webpack\')\nmodule.exports = {\n  plugins: [new webpack.ProvidePlugin({ $: \'jquery\' })]\n}\n\n// index.js\nconsole.log($)\n```\n\n传送门 ==> [webpack.ProvidePlugin](https://www.webpackjs.com/plugins/provide-plugin/)\n\n### webpack.DefinePlugin\n\n> `DefinePlugin` 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。如果在开发构建中，而不在发布构建中执行日志记录，则可以使用全局常量来决定是否记录日志。这就是 `DefinePlugin` 的用处，设置它，就可以忘记开发和发布构建的规则。\n\n```js\nmodule.exports = {\n  plugins: [\n    new webpack.DefinePlugin({\n      PRODUCTION: JSON.stringify(true)\n    })\n  ]\n}\n\n// index.js\nconsole.log(PRODUCTION) // true\n```\n\n传送门 ==> [webpack.DefinePlugin](https://www.webpackjs.com/plugins/define-plugin/)\n\n### mini-css-extract-plugin\n\n`mini-css-extract-plugin`，它默认就会对你的样式进行模块化拆分。相对 `extract-text-webpack-plugin`。 即 css 异步按需加载\n\n```js\nconst MiniCssExtractPlugin = require(\'mini-css-extract-plugin\') // 抽取 css 到独立文件\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        include: [path.resolve(__dirname, \'src\')],\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n            options: {\n              publicPath: \'../\' // chunk publicPath\n            }\n          },\n          \'css-loader\'\n        ]\n      }\n    ]\n  },\n\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \'css/[name].[hash:8].css\', //这里配置跟output写法一致\n      chunkFilename: \'css/[id][chunkhash:8].css\'\n    })\n  ]\n}\n```\n\n传送门 ==> [mini-css-extract-plugin](https://www.npmjs.com/package/mini-css-extract-plugin)\n\n## 编译结果优化类\n\n### wbepack.IgnorePlugin\n\n防止在 import 或 require 调用时，生成以下正则表达式匹配的模块：\n\n- `requestRegExp` 匹配(test)资源请求路径的正则表达式。\n- `contextRegExp` （可选）匹配(test)资源上下文（目录）的正则表达式。\n\nmoment 2.18 会将所有本地化内容和核心功能一起打包（见该 [GitHub issue](https://github.com/moment/moment/issues/2373)）。你可使用 IgnorePlugin 在打包时忽略本地化内容:\n\n```js\nnew webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/)\n```\n\n传送门 ==> [wbepack.IgnorePlugin](https://www.webpackjs.com/plugins/ignore-plugin/)\n\n### uglifyjs-webpack-plugin\n\n- js 代码压缩,默认会使用 `optimization.minimizer`，\n- `cache`: Boolean/String ,字符串即是缓存文件存放的路径；\n- `test`：正则表达式、字符串、数组都可以，用于只匹配某些文件，如：/.js(?.\\*)?\\$/i;\n- `parallel` : 启用多线程并行运行来提高编译速度，经常编译的时候听到电脑跑的呼呼响，可能就是它干的，哈哈～；\n- `output.comments` ： 删除所有注释，\n- `compress.warnings` ：插件在进行删除一些无用代码的时候，不提示警告，\n- `compress.drop_console`：喜欢打 console 的同学，它能自动帮你过滤掉，再也不用担心线上还打印日志了；\n\n```js\nconst UglifyJsPlugin = require(\'uglifyjs-webpack-plugin\')\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      new UglifyJsPlugin({\n        cache: true, // 开启缓存\n        parallel: true, // 开启多线程编译\n        sourceMap: true, // 是否sourceMap\n        // 丑化参数\n        uglifyOptions: {\n          comments: false,\n          warnings: false,\n          compress: {\n            unused: true,\n            dead_code: true,\n            collapse_vars: true,\n            reduce_vars: true\n          },\n          output: {\n            comments: false\n          }\n        }\n      })\n    ]\n  }\n}\n```\n\n传送门 ==> [uglifyjs-webpack-plugin](https://www.npmjs.com/package/uglifyjs-webpack-plugin)\n\n### optimize-css-assets-webpack-plugin\n\n它的作用在于压缩 css 文件\n\n- `assetNameRegExp`：默认是全部的 css 都会压缩，该字段可以进行指定某些要处理的文件，\n- `cssProcessor`：指定一个优化 css 的处理器，默认 cssnano，\n- `cssProcessorPluginOptions`：cssProcessor 后面可以跟一个 process 方法，会返回一个 promise 对象，而 cssProcessorPluginOptions 就是一个 options 参数选项！\n- `canPrint`：布尔，是否要将编译的消息显示在控制台，没发现有什么用！\n- 坑点 ：建议使用高版本的包，之前低版本有遇到样式丢失把各浏览器前缀干掉的问题，\n\n```js\nconst OptimizeCssAssetsPlugin = require(\'optimize-css-assets-webpack-plugin\') // 丑化 css\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      new OptimizeCssAssetsPlugin({\n        cssProcessor: require(\'cssnano\'), // css 压缩优化器\n        cssProcessorOptions: { discardComments: { removeAll: true } } // 去除所有注释\n      })\n    ]\n  }\n}\n```\n\n传送门 ==> [optimize-css-assets-webpack-plugin](https://www.npmjs.com/package/optimize-css-assets-webpack-plugin)\n\n### SplitChunksPlugin\n\n`webpack` 把 `chunk` 分为两种类型，一种是初始加载 `initial chunk`，另外一种是异步加载 `async chunk`，如果不配置 ` SplitChunksPlugin，``webpack ` 会在 production 的模式下自动开启，默认情况下，`webpack` 会将 `node_modules` 下的所有模块定义为异步加载模块，并分析你的 `entry`、动态加载（`import()`、require.ensure）模块，找出这些模块之间共用的 `node_modules` 下的模块，并将这些模块提取到单独的 `chunk` 中，在需要的时候异步加载到页面当中，其中默认配置如下：\n\n```js\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: \'async\', // 异步加载chunk\n      minSize: 30000,\n      maxSize: 0,\n      minChunks: 1,\n      maxAsyncRequests: 5,\n      maxInitialRequests: 3,\n      automaticNameDelimiter: \'~\', // 文件名中chunk分隔符\n      name: true,\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/, //\n          priority: -10\n        },\n        default: {\n          minChunks: 2, // 最小的共享chunk数\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n}\n```\n\n传送门 ==> [SplitChunksPlugin](https://www.webpackjs.com/plugins/split-chunks-plugin/)\n\n### webpack.HotModuleReplacementPlugin\n\n热更新, 配合 `webpack-dev-server` 使用\n\n```js\nyarn add webpack-dev-server -D\n```\n\n```js\nnew webpack.HotModuleReplacementPlugin()\n\nmodule.exports = {\n  devServer: {\n    port: 1234,\n    open: true, // 自动打开浏览器\n    compress: true, // 服务器压缩\n    hot: true // 开启热加载\n    //... proxy、hot\n  },\n  plugins: [new webpack.HotModuleReplacementPlugin()]\n}\n\n// index.js\n\nif (module.hot) {\n  module.hot.accept()\n}\n```\n\n- 传送门 ==> [devServer](https://www.webpackjs.com/configuration/dev-server/)\n- 传送门 ==> [webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server)\n\n## 加快编译速度\n\n### DllPlugin && DllReferencePlugin && autodll-webpack-plugin\n\n`DllPlugin` 和 `DllReferencePlugin` 提供分离包的方式可以大大提高构建时间性能。主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这部分代码进行打包。从而节省了打包时间。\n\nDllPlugin 插件：用于打包出一个个单独的动态链接库文件。\nDllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。\n\n- `DllPlugin`\n  - `context (optional)`: manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context))\n  - `name`: 暴露出的 DLL 的函数名 (TemplatePaths: [hash] & [name] )\n  - `path`: manifest json 文件的绝对路径 (输出文件)\n\n`DllReferencePlugin`: 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。\n\n- `DllReferencePlugin`\n  - `context`: (绝对路径) manifest (或者是内容属性)中请求的上下文\n  - `manifest`: 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径\n  - `content (optional)`: 请求到模块 id 的映射 (默认值为 manifest.content)\n  - `name (optional)`: dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals)\n  - `scope (optional)`: dll 中内容的前缀\n  - `sourceType (optional)`: dll 是如何暴露的 (libraryTarget)\n\n```js\n```\n\n传送门 ==> [DllPlugin](https://www.webpackjs.com/plugins/dll-plugin/)\n', '2019-02-01 05:06:36', '2019-02-23 05:06:36',1);
INSERT INTO `article` VALUES (68, 'git 实用指南', '\n## commit 规范速查\n\n- `feat`：新功能（feature）\n- `fix`：修补 bug\n- `docs`：文档（documentation）\n- `style`： 格式（不影响代码运行的变动）\n- `refactor`：重构（即不是新增功能，也不是修改 bug 的代码变动）\n- `test`：增加测试\n- `chore`：构建过程或辅助工具的变动\n- `revert`: 撤销以前的 commit\n \n ```bash\n revert: feat(pencil): add \'graphiteWidth\' option\n ```\n\n<!--more-->\n\n## 本地创建、连接远程仓库\n\n```bash\n# 创建并连接远程仓库\nmkdir git-demo\n\ncd git-demo/\n\ngit init\n\n# 连接远程仓库\ngit remote add origin https://github.com/gershonv/git-demo.git\n```\n\n## 新建文件并推向远端\n\n```bash\n# 创建 a.js\ntouch a.js\n\n# 添加到暂存区（见下文）\ngit add .\n\n# commit 记录（见下文）\ngit commit -m \'feat: 新增 a.js 文件\'\n\n# 推向远端 master 分支（见下文）\ngit push origin master\n```\n\n- git add\n  - `git add [file1 file2 file3...]`: 添加多个文件\n  - `git add .` : 暂存所有文件\n\n## git status\n\n![](https://user-gold-cdn.xitu.io/2019/1/8/1682b86ab859defb?w=505&h=412&f=png&s=45734)\n\nM - 被修改，A - 被添加，D - 被删除，R - 重命名，?? - 未被跟踪\n\n## 撤销操作\n\n### 撤销 git add\n\n```bash\n# 新建 b.js 文件\ntouch b.js\n\ngit add .\n\ngit statis\n\n# 撤销 git add\ngit reset head b.js\n```\n\n- `git reset head` : 如果后面什么都不跟的话 就是上一次 add 里面的全部撤销了\n- `git reset head file`: 对某个文件进行撤销了\n\n### 撤销本地修改\n\n```bash\n# 修改文件\nvim a.js\n\n# 插入数据\nshift + i\n\n# 保存退出\nshift + : wq\n\n# 加入暂存区\ngit add .\n\ngit commit -m \'refactor: 修改 a.js 文件\'\n\n# 撤销修改\ngit checkout -- a.js\n```\n\n### 撤销 git commit\n\n```bash\n# 查看 commit 记录\ngit log\n\n# 重置到某个节点。\ngit reset --hard ea794cf0dcf934b594\n```\n\n## 分支\n\n### 新建分支并推向远程\n\n```bash\n# 新建并切换本地分支\ngit checkout -b dev\n\n# 查看当前分支\ngit branch\n\n# 查看远程分支\ngit branch -r\n\n# 推送到远程\ngit push origin dev\n```\n\n### 合并分支\n\n```bash\n# 开发完 dev 分支后\ngit checkout master\n\n# 合并 dev 分支到主分支\ngit merge dev\n\n# 推送\ngit push origin master\n```\n\n### 分支管理\n\n```bash\n# 查看所有分支 远程+本地\ngit branch -a\n\n# 删除远程分支\ngit push origin -d dev\n\n# 删除本地分支\ngit checkout master\ngit branch -d dev\n```', '2019-02-02 05:08:12', '2019-02-23 05:08:12',1);
INSERT INTO `article` VALUES (69, 'koa2-基础知识', '## 起步\n\n```\nnpm i koa -S\n```\n\n```js\nconst Koa = require(\'koa\')\n\nconst app = new Koa()\n\napp.use(async ctx => {\n  ctx.body = \'hello koa\'\n})\n\napp.listen(3000, () => {\n  console.log(\'app listen on http://127.0.0.1:3000\')\n})\n```\n<!--more-->\n\n## 接收 get / post 请求\n\n### get => ctx.query\n\n```js\napp.use(async ctx => {\n  /**\n   * test: http://localhost:3000/?username=guodada\n   * url: /?username=guodada\n   * query: {username: \"guodada\"}\n   * querystring: username=guodada\n   * request: { header, method, url}\n   */\n  let { url, request, query, querystring } = ctx\n  ctx.body = { url, request, query, querystring }\n})\n```\n\n- `query`：返回的是格式化好的参数对象。\n- `querystring`：返回的是请求字符串。\n\n### post => ctx.request.body\n\n对于 `POST` 请求的处理，`Koa2` 没有封装方便的获取参数的方法，需要通过解析上下文 `context` 中的原生 `node.js` 请求对象 `req` 来获取。\n\n```js\n// 将 useraname=guodada&age=22 解析为 { \"useraname\": \"guodada\", \"age\":  22 }\nconst parseQueryStr = queryStr => {\n  let queryData = {}\n  let queryStrList = queryStr.split(\'&\')\n  for (let [index, queryStr] of queryStrList.entries()) {\n    let itemList = queryStr.split(\'=\')\n    queryData[itemList[0]] = decodeURIComponent(itemList[1])\n  }\n  return queryData\n}\n\n// 解析 post 得到的数据\nconst parsePostData = ctx => {\n  return new Promise((resolve, reject) => {\n    try {\n      let postString = \'\'\n      ctx.req.on(\'data\', chunk => {\n        postString += chunk\n      })\n      ctx.req.on(\'end\', chunk => {\n        // postString : useraname=guodada&age=22\n        let parseData = parseQueryStr(postString)\n        resolve(parseData)\n      })\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n\n// 测试用例：post : { \"useraname\": \"guodada\", \"age\":  22 }\napp.use(async ctx => {\n  if (ctx.method === \'POST\') {\n    const data = await parsePostData(ctx)\n    ctx.body = data\n  }\n})\n```\n\n### koa-bodyparser\n\n上面解析 `post` 数据就是 `koa-bodyparser` 中间件函数的雏形，不需要我们写，直接使用这个中间件就可以了\n\n```\nnpm i koa-bodyparser -S\n```\n\n```js\nconst Koa = require(\'koa\')\nconst bodyParser = require(\'koa-bodyparser\')\n\nconst app = new Koa()\n\napp.use(bodyParser())\n\napp.use(async ctx => {\n  ctx.body = ctx.request.body\n})\n\n//...\n```\n\n## koa-router\n\n主要是通过 `ctx.request.url` 获取地址栏输入的路径，根据路径不同进行跳转。这里不做实现。使用已有的中间件 `koa-router`\n\n```\nnpm install koa-router -S\n```\n\n```js\nconst Router = require(\'koa-router\')\nconst router = new Router()\n\nrouter.get(\'/\', function(ctx, next) {\n  ctx.body = \'Hello index\'\n})\n\napp\n  .use(router.routes()) // 作用：启动路由\n  .use(router.allowedMethods()) // 作用：这是官方推荐用法，我们可以看到 router.allowedMethods() 用在路由匹配\n// router.routes() 之后，所以在所有路由中间件最后调用，此时根据 ctx.status 设置 response 响应头\n```\n\n### 路由层级\n\n```js\nconst router = new Router()\nconst page = new Router()\n\n// page 路由\npage\n  .get(\'/info\', async ctx => {\n    ctx.body = \'url: /page/info\'\n  })\n  .get(\'/todo\', async ctx => {\n    ctx.body = \'url: /page/todo\'\n  })\n\nrouter.use(\'/page\', page.routes(), page.allowedMethods())\n\napp.use(router.routes()).use(router.allowedMethods())\n\n// 输入 localhost:3000/page/info 可以去到 page 的路由...\n```\n\n## cookie\n\n`koa` 的上下文（`ctx`）直接提供了 `cookie` 读取和写入的方法\n\n- `ctx.cookies.get(name,[optins])`:读取上下文请求中的 cookie。\n- `ctx.cookies.set(name,value,[options])`：在上下文中写入 cookie。\n\n```js\napp.use(async ctx => {\n  ctx.cookies.set(\'username\', \'guodada\', {\n    domain: \'127.0.0.1\', // 写cookie所在的域名\n    path: \'/\', // 写cookie所在的路径\n    maxAge: 1000 * 60 * 60 * 24, // cookie有效时长\n    expires: new Date(\'2018-12-31\'), // cookie失效时间\n    httpOnly: false, // 是否只用于http请求中获取 默认是 true\n    overwrite: false // 是否允许重写 默认是 false\n  })\n  ctx.body = ctx.cookies.get(\'username\') // guodada\n})\n```\n\n## koa-static 静态资源中间件\n\n```js\nconst path = require(\'path\')\nconst static = require(\'koa-static\')\nconst staticPath = \'./static\'\n\napp.use(static(\n  path.join( __dirname,  staticPath)\n))\n```\n\n我们 新建 `static/baidu.png`, 地址输入 `localhost:3000/baidu.png` 就可以直接访问静态资源了。', '2019-02-23 05:09:15', '2019-02-23 05:09:15',1);
COMMIT;

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `articleId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `articleId` (`articleId`),
  CONSTRAINT `category_ibfk_1` FOREIGN KEY (`articleId`) REFERENCES `article` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of category
-- ----------------------------
BEGIN;
INSERT INTO `category` VALUES (3, 'MySQL', 1);
INSERT INTO `category` VALUES (5, 'MySQL', 2);
INSERT INTO `category` VALUES (7, 'MySQL', 3);
INSERT INTO `category` VALUES (8, 'MySQL', 4);
INSERT INTO `category` VALUES (29, 'React', 15);
INSERT INTO `category` VALUES (30, 'React', 16);
INSERT INTO `category` VALUES (37, 'Sequelize', 23);
INSERT INTO `category` VALUES (38, 'Sequelize', 24);
INSERT INTO `category` VALUES (39, 'Sequelize', 25);
INSERT INTO `category` VALUES (40, 'Sequelize', 26);
INSERT INTO `category` VALUES (41, 'Sequelize', 27);
INSERT INTO `category` VALUES (42, 'Sequelize', 28);
INSERT INTO `category` VALUES (43, 'Vue', 29);
INSERT INTO `category` VALUES (44, 'Vue', 30);
INSERT INTO `category` VALUES (45, 'Vue', 31);
INSERT INTO `category` VALUES (46, 'Vue', 32);
INSERT INTO `category` VALUES (47, 'Javascript', 33);
INSERT INTO `category` VALUES (48, 'Javascript', 34);
INSERT INTO `category` VALUES (49, 'Javascript', 35);
INSERT INTO `category` VALUES (50, 'Javascript', 36);
INSERT INTO `category` VALUES (51, 'HTTP', 37);
INSERT INTO `category` VALUES (52, 'HTTP', 38);
INSERT INTO `category` VALUES (53, 'HTTP', 39);
INSERT INTO `category` VALUES (54, 'HTTP', 40);
INSERT INTO `category` VALUES (55, 'HTTP', 41);
INSERT INTO `category` VALUES (56, 'HTTP', 42);
INSERT INTO `category` VALUES (57, 'Javascript', 43);
INSERT INTO `category` VALUES (58, 'Javascript', 44);
INSERT INTO `category` VALUES (59, 'Javascript', 45);
INSERT INTO `category` VALUES (60, 'Javascript', 46);
INSERT INTO `category` VALUES (61, 'Javascript', 47);
INSERT INTO `category` VALUES (62, 'Javascript', 48);
INSERT INTO `category` VALUES (63, 'Javascript', 49);
INSERT INTO `category` VALUES (64, 'Javascript', 50);
INSERT INTO `category` VALUES (65, 'Javascript', 51);
INSERT INTO `category` VALUES (66, 'Javascript', 52);
INSERT INTO `category` VALUES (67, 'Javascript', 53);
INSERT INTO `category` VALUES (68, 'Javascript', 54);
INSERT INTO `category` VALUES (69, 'Javascript', 55);
INSERT INTO `category` VALUES (70, 'Javascript', 56);
INSERT INTO `category` VALUES (71, 'Javascript', 57);
INSERT INTO `category` VALUES (72, 'Javascript', 58);
INSERT INTO `category` VALUES (73, 'Javascript', 59);
INSERT INTO `category` VALUES (74, 'Javascript', 60);
INSERT INTO `category` VALUES (75, 'HTML-CSS', 61);
INSERT INTO `category` VALUES (76, 'HTML-CSS', 62);
INSERT INTO `category` VALUES (77, 'Javascript', NULL);
INSERT INTO `category` VALUES (78, 'React', 22);
INSERT INTO `category` VALUES (79, 'React', 21);
INSERT INTO `category` VALUES (80, 'React', 20);
INSERT INTO `category` VALUES (81, 'React', 19);
INSERT INTO `category` VALUES (82, 'React', 18);
INSERT INTO `category` VALUES (83, 'React', 17);
INSERT INTO `category` VALUES (84, 'React', 14);
INSERT INTO `category` VALUES (85, 'React', 13);
INSERT INTO `category` VALUES (86, 'React', 12);
INSERT INTO `category` VALUES (87, 'React', 11);
INSERT INTO `category` VALUES (88, 'React', 10);
INSERT INTO `category` VALUES (89, 'React', 9);
INSERT INTO `category` VALUES (90, 'React', 8);
INSERT INTO `category` VALUES (91, 'React', 7);
INSERT INTO `category` VALUES (92, 'React', 6);
INSERT INTO `category` VALUES (93, 'React', 5);
INSERT INTO `category` VALUES (94, 'webpack', 64);
INSERT INTO `category` VALUES (95, 'webpack', 65);
INSERT INTO `category` VALUES (96, 'webpack', 66);
INSERT INTO `category` VALUES (97, 'webpack', 67);
INSERT INTO `category` VALUES (98, 'git', 68);
INSERT INTO `category` VALUES (99, 'koa2', 69);
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `articleId` int(11) DEFAULT NULL,
  `content` text,
  `createdAt` datetime DEFAULT NULL,
  `updatedAt` datetime DEFAULT NULL,
  `userId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `articleId` (`articleId`),
  KEY `userId` (`userId`),
  CONSTRAINT `comment_ibfk_1` FOREIGN KEY (`articleId`) REFERENCES `article` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `comment_ibfk_2` FOREIGN KEY (`userId`) REFERENCES `user` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=52 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
BEGIN;
INSERT INTO `comment` VALUES (50, -1, '留言测试', '2019-02-25 05:48:26', '2019-02-25 05:48:26', 1);
INSERT INTO `comment` VALUES (51, 69, '```js\nvar a = 1\n```', '2019-02-25 05:48:47', '2019-02-25 05:48:47', 1);
COMMIT;

-- ----------------------------
-- Table structure for example
-- ----------------------------
DROP TABLE IF EXISTS `example`;
CREATE TABLE `example` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `artcle` text,
  `username` varchar(20) NOT NULL,
  `password` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Table structure for examples
-- ----------------------------
DROP TABLE IF EXISTS `examples`;
CREATE TABLE `examples` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `artcle` text,
  `username` varchar(20) NOT NULL,
  `password` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for reply
-- ----------------------------
DROP TABLE IF EXISTS `reply`;
CREATE TABLE `reply` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text,
  `createdAt` datetime DEFAULT NULL,
  `updatedAt` datetime DEFAULT NULL,
  `commentId` int(11) DEFAULT NULL,
  `articleId` int(11) DEFAULT NULL,
  `userId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `userId` (`userId`),
  CONSTRAINT `reply_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `user` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of reply
-- ----------------------------
BEGIN;
INSERT INTO `reply` VALUES (13, '第一条回复', '2019-02-23 05:36:25', '2019-02-23 05:36:25', 41, NULL, NULL);
INSERT INTO `reply` VALUES (22, '回复测试', '2019-02-25 05:48:34', '2019-02-25 05:48:34', 50, NULL, 1);
COMMIT;

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `articleId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `articleId` (`articleId`),
  CONSTRAINT `tag_ibfk_1` FOREIGN KEY (`articleId`) REFERENCES `article` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=140 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of tag
-- ----------------------------
BEGIN;
INSERT INTO `tag` VALUES (2, 'MySQL', 1);
INSERT INTO `tag` VALUES (4, 'MySQL', 2);
INSERT INTO `tag` VALUES (6, 'MySQL', 3);
INSERT INTO `tag` VALUES (7, 'MySQL', 4);
INSERT INTO `tag` VALUES (18, 'React', 15);
INSERT INTO `tag` VALUES (19, 'React', 16);
INSERT INTO `tag` VALUES (38, 'Sequelize', 23);
INSERT INTO `tag` VALUES (39, 'Sequelize', 24);
INSERT INTO `tag` VALUES (40, 'Sequelize', 25);
INSERT INTO `tag` VALUES (41, 'Sequelize', 26);
INSERT INTO `tag` VALUES (42, 'Sequelize', 27);
INSERT INTO `tag` VALUES (43, 'Sequelize', 28);
INSERT INTO `tag` VALUES (44, 'Vue', 29);
INSERT INTO `tag` VALUES (45, 'Vue', 30);
INSERT INTO `tag` VALUES (46, 'MVVM', 30);
INSERT INTO `tag` VALUES (47, 'Vue', 31);
INSERT INTO `tag` VALUES (49, 'Vue', 32);
INSERT INTO `tag` VALUES (51, 'ES6', 33);
INSERT INTO `tag` VALUES (52, 'ES6', 34);
INSERT INTO `tag` VALUES (53, 'ES6', 35);
INSERT INTO `tag` VALUES (54, 'Javascript', 35);
INSERT INTO `tag` VALUES (55, 'Javascript', 33);
INSERT INTO `tag` VALUES (56, 'Javascript', 34);
INSERT INTO `tag` VALUES (57, 'ES6', 36);
INSERT INTO `tag` VALUES (58, 'Javascript', 36);
INSERT INTO `tag` VALUES (59, 'HTTP', 37);
INSERT INTO `tag` VALUES (60, 'HTTP', 38);
INSERT INTO `tag` VALUES (61, 'HTTP', 39);
INSERT INTO `tag` VALUES (62, '跨域', 39);
INSERT INTO `tag` VALUES (63, 'HTTP', 40);
INSERT INTO `tag` VALUES (65, 'HTTP', 41);
INSERT INTO `tag` VALUES (66, 'HTTP', 42);
INSERT INTO `tag` VALUES (67, 'regexp', 43);
INSERT INTO `tag` VALUES (68, 'Javascript', 43);
INSERT INTO `tag` VALUES (69, 'Javascript', 44);
INSERT INTO `tag` VALUES (70, 'Javascript', 45);
INSERT INTO `tag` VALUES (71, '设计模式', 45);
INSERT INTO `tag` VALUES (72, 'Javascript', 46);
INSERT INTO `tag` VALUES (73, 'Javascript', 47);
INSERT INTO `tag` VALUES (74, 'Javascript 深入系列', 47);
INSERT INTO `tag` VALUES (75, '原型原型链', 47);
INSERT INTO `tag` VALUES (76, 'Javascript', 48);
INSERT INTO `tag` VALUES (77, 'Javascript 深入系列', 48);
INSERT INTO `tag` VALUES (78, '作用域', 48);
INSERT INTO `tag` VALUES (79, 'Javascript', 49);
INSERT INTO `tag` VALUES (80, 'Javascript 深入系列', 49);
INSERT INTO `tag` VALUES (81, '执行上下文', 49);
INSERT INTO `tag` VALUES (82, 'Javascript', 50);
INSERT INTO `tag` VALUES (83, 'Javascript 深入系列', 50);
INSERT INTO `tag` VALUES (84, 'Javascript', 51);
INSERT INTO `tag` VALUES (85, 'Javascript 深入系列', 51);
INSERT INTO `tag` VALUES (86, '原型原型链', 51);
INSERT INTO `tag` VALUES (87, 'Javascript', 52);
INSERT INTO `tag` VALUES (88, 'Javascript 深入系列', 52);
INSERT INTO `tag` VALUES (89, 'this', 52);
INSERT INTO `tag` VALUES (90, 'Javascript', 53);
INSERT INTO `tag` VALUES (91, 'Javascript 深入系列', 53);
INSERT INTO `tag` VALUES (92, '执行上下文', 53);
INSERT INTO `tag` VALUES (93, 'Javascript', 54);
INSERT INTO `tag` VALUES (94, 'Javascript 深入系列', 54);
INSERT INTO `tag` VALUES (95, '闭包', 54);
INSERT INTO `tag` VALUES (96, 'Javascript 深入系列', 55);
INSERT INTO `tag` VALUES (97, 'Javascript', 55);
INSERT INTO `tag` VALUES (98, 'Javascript 深入系列', 56);
INSERT INTO `tag` VALUES (99, 'Javascript', 56);
INSERT INTO `tag` VALUES (100, 'Javascript 深入系列', 57);
INSERT INTO `tag` VALUES (101, 'Javascript', 57);
INSERT INTO `tag` VALUES (102, 'Javascript 深入系列', 58);
INSERT INTO `tag` VALUES (103, 'Javascript', 58);
INSERT INTO `tag` VALUES (104, 'Javascript 深入系列', 59);
INSERT INTO `tag` VALUES (105, 'Javascript', 59);
INSERT INTO `tag` VALUES (106, 'Javascript 深入系列', 60);
INSERT INTO `tag` VALUES (107, 'Javascript', 60);
INSERT INTO `tag` VALUES (108, 'CSS', 61);
INSERT INTO `tag` VALUES (109, 'flex', 61);
INSERT INTO `tag` VALUES (110, 'canvas', 62);
INSERT INTO `tag` VALUES (112, 'React', 22);
INSERT INTO `tag` VALUES (113, 'React-Router', 22);
INSERT INTO `tag` VALUES (114, 'React', 21);
INSERT INTO `tag` VALUES (115, 'React-Router', 21);
INSERT INTO `tag` VALUES (116, 'React', 20);
INSERT INTO `tag` VALUES (117, 'React-Router', 20);
INSERT INTO `tag` VALUES (118, 'React', 19);
INSERT INTO `tag` VALUES (119, 'React-Router', 19);
INSERT INTO `tag` VALUES (120, 'React', 18);
INSERT INTO `tag` VALUES (121, 'React-Router', 18);
INSERT INTO `tag` VALUES (122, 'React', 17);
INSERT INTO `tag` VALUES (123, 'React-Router', 17);
INSERT INTO `tag` VALUES (124, 'React', 14);
INSERT INTO `tag` VALUES (125, 'React', 13);
INSERT INTO `tag` VALUES (126, 'React', 12);
INSERT INTO `tag` VALUES (127, 'React', 11);
INSERT INTO `tag` VALUES (128, 'React', 10);
INSERT INTO `tag` VALUES (129, 'React', 9);
INSERT INTO `tag` VALUES (130, 'React', 8);
INSERT INTO `tag` VALUES (131, 'React', 7);
INSERT INTO `tag` VALUES (132, 'React', 6);
INSERT INTO `tag` VALUES (133, 'React', 5);
INSERT INTO `tag` VALUES (134, 'webpack', 64);
INSERT INTO `tag` VALUES (135, 'webpack', 65);
INSERT INTO `tag` VALUES (136, 'webpack', 66);
INSERT INTO `tag` VALUES (137, 'webpack', 67);
INSERT INTO `tag` VALUES (138, 'tools', 68);
INSERT INTO `tag` VALUES (139, 'node', 69);
COMMIT;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL,
  `password` varchar(255) NOT NULL,
  `auth` tinyint(4) DEFAULT '0',
  `createdAt` datetime DEFAULT NULL,
  `updatedAt` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES (1, 'admin', '$2b$10$rIIL/G.YJS1/a73MdawcHeCXnQmf9BElyWbZ.yTn5kGm8HE.bPej2', 1, '2019-02-25 05:47:02', '2019-02-25 05:47:02');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
